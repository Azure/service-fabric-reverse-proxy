// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lds.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2 {

  /// <summary>Holder for reflection information generated from lds.proto</summary>
  public static partial class LdsReflection {

    #region Descriptor
    /// <summary>File descriptor for lds.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static LdsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CglsZHMucHJvdG8SDGVudm95LmFwaS52MhofZW52b3kvYXBpL3YyL2NvcmUv",
            "YWRkcmVzcy5wcm90bxocZW52b3kvYXBpL3YyL2NvcmUvYmFzZS5wcm90bxoc",
            "ZW52b3kvYXBpL3YyL2Rpc2NvdmVyeS5wcm90bxokZW52b3kvYXBpL3YyL2xp",
            "c3RlbmVyL2xpc3RlbmVyLnByb3RvGhxnb29nbGUvYXBpL2Fubm90YXRpb25z",
            "LnByb3RvGh5nb29nbGUvcHJvdG9idWYvd3JhcHBlcnMucHJvdG8aF3ZhbGlk",
            "YXRlL3ZhbGlkYXRlLnByb3RvGhRnb2dvcHJvdG8vZ29nby5wcm90byL6BAoI",
            "TGlzdGVuZXISDAoEbmFtZRgBIAEoCRI7CgdhZGRyZXNzGAIgASgLMhouZW52",
            "b3kuYXBpLnYyLmNvcmUuQWRkcmVzc0IOuunAAwWKAQIQAcjeHwASSgoNZmls",
            "dGVyX2NoYWlucxgDIAMoCzIjLmVudm95LmFwaS52Mi5saXN0ZW5lcjIuRmls",
            "dGVyQ2hhaW5CDrrpwAMFkgECCAHI3h8AEjgKEHVzZV9vcmlnaW5hbF9kc3QY",
            "BCABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlQgIYARJHCiFwZXJf",
            "Y29ubmVjdGlvbl9idWZmZXJfbGltaXRfYnl0ZXMYBSABKAsyHC5nb29nbGUu",
            "cHJvdG9idWYuVUludDMyVmFsdWUSLQoIbWV0YWRhdGEYBiABKAsyGy5lbnZv",
            "eS5hcGkudjIuY29yZS5NZXRhZGF0YRI6Cg1kZXByZWNhdGVkX3YxGAcgASgL",
            "MiMuZW52b3kuYXBpLnYyLkxpc3RlbmVyLkRlcHJlY2F0ZWRWMRI0CgpkcmFp",
            "bl90eXBlGAggASgOMiAuZW52b3kuYXBpLnYyLkxpc3RlbmVyLkRyYWluVHlw",
            "ZRJGChBsaXN0ZW5lcl9maWx0ZXJzGAkgAygLMiYuZW52b3kuYXBpLnYyLmxp",
            "c3RlbmVyMi5MaXN0ZW5lckZpbHRlckIEyN4fABpACgxEZXByZWNhdGVkVjES",
            "MAoMYmluZF90b19wb3J0GAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLkJvb2xW",
            "YWx1ZSIpCglEcmFpblR5cGUSCwoHREVGQVVMVBAAEg8KC01PRElGWV9PTkxZ",
            "EAEy6wEKGExpc3RlbmVyRGlzY292ZXJ5U2VydmljZRJYCg9TdHJlYW1MaXN0",
            "ZW5lcnMSHi5lbnZveS5hcGkudjIuRGlzY292ZXJ5UmVxdWVzdBofLmVudm95",
            "LmFwaS52Mi5EaXNjb3ZlcnlSZXNwb25zZSIAKAEwARJ1Cg5GZXRjaExpc3Rl",
            "bmVycxIeLmVudm95LmFwaS52Mi5EaXNjb3ZlcnlSZXF1ZXN0Gh8uZW52b3ku",
            "YXBpLnYyLkRpc2NvdmVyeVJlc3BvbnNlIiKC0+STAhwiFy92Mi9kaXNjb3Zl",
            "cnk6bGlzdGVuZXJzOgEqQgSo4h4BYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.AddressReflection.Descriptor, global::Envoy.Api.V2.Core.BaseReflection.Descriptor, global::Envoy.Api.V2.DiscoveryReflection.Descriptor, global::Envoy.Api.V2.Listener2.ListenerReflection.Descriptor, global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, global::Gogoproto.GogoReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Listener), global::Envoy.Api.V2.Listener.Parser, new[]{ "Name", "Address", "FilterChains", "UseOriginalDst", "PerConnectionBufferLimitBytes", "Metadata", "DeprecatedV1", "DrainType", "ListenerFilters" }, null, new[]{ typeof(global::Envoy.Api.V2.Listener.Types.DrainType) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Listener.Types.DeprecatedV1), global::Envoy.Api.V2.Listener.Types.DeprecatedV1.Parser, new[]{ "BindToPort" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class Listener : pb::IMessage<Listener> {
    private static readonly pb::MessageParser<Listener> _parser = new pb::MessageParser<Listener>(() => new Listener());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Listener> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.LdsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Listener() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Listener(Listener other) : this() {
      name_ = other.name_;
      Address = other.address_ != null ? other.Address.Clone() : null;
      filterChains_ = other.filterChains_.Clone();
      UseOriginalDst = other.UseOriginalDst;
      PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
      Metadata = other.metadata_ != null ? other.Metadata.Clone() : null;
      DeprecatedV1 = other.deprecatedV1_ != null ? other.DeprecatedV1.Clone() : null;
      drainType_ = other.drainType_;
      listenerFilters_ = other.listenerFilters_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Listener Clone() {
      return new Listener(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The unique name by which this listener is known. If no name is provided,
    /// Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
    /// updated or removed via :ref:`LDS &lt;config_listeners_lds>` a unique name must be provided.
    /// By default, the maximum length of a listener's name is limited to 60 characters. This limit can
    /// be increased by setting the :option:`--max-obj-name-len` command line argument to the desired
    /// value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 2;
    private global::Envoy.Api.V2.Core.Address address_;
    /// <summary>
    /// The address that the listener should listen on. In general, the address must be unique, though
    /// that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
    /// Linux as the actual port will be allocated by the OS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Address Address {
      get { return address_; }
      set {
        address_ = value;
      }
    }

    /// <summary>Field number for the "filter_chains" field.</summary>
    public const int FilterChainsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Listener2.FilterChain> _repeated_filterChains_codec
        = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.Listener2.FilterChain.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Listener2.FilterChain> filterChains_ = new pbc::RepeatedField<global::Envoy.Api.V2.Listener2.FilterChain>();
    /// <summary>
    /// A list of filter chains to consider for this listener. The
    /// :ref:`FilterChain &lt;envoy_api_msg_listener.FilterChain>` with the most specific
    /// :ref:`FilterChainMatch &lt;envoy_api_msg_listener.FilterChainMatch>` criteria is used on a
    /// connection.
    ///
    /// .. attention::
    ///
    ///   In the current version, multiple filter chains are supported **only** so that SNI can be
    ///   configured. See the :ref:`FAQ entry &lt;faq_how_to_setup_sni>` on how to configure SNI for more
    ///   information. When multiple filter chains are configured, each filter chain must have an
    ///   **identical** set of :ref:`filters &lt;envoy_api_field_listener.FilterChain.filters>`. If the
    ///   filters differ, the configuration will fail to load. In the future, this limitation will be
    ///   relaxed such that different filters can be used depending on which filter chain matches
    ///   (based on SNI or some other parameter).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Listener2.FilterChain> FilterChains {
      get { return filterChains_; }
    }

    /// <summary>Field number for the "use_original_dst" field.</summary>
    public const int UseOriginalDstFieldNumber = 4;
    private static readonly pb::FieldCodec<bool?> _single_useOriginalDst_codec = pb::FieldCodec.ForStructWrapper<bool>(34);
    private bool? useOriginalDst_;
    /// <summary>
    /// If a connection is redirected using *iptables*, the port on which the proxy
    /// receives it might be different from the original destination address. When this flag is set to
    /// true, the listener hands off redirected connections to the listener associated with the
    /// original destination address. If there is no listener associated with the original destination
    /// address, the connection is handled by the listener that receives it. Defaults to false.
    ///
    /// .. attention::
    ///
    ///   This field is deprecated. Use :ref:`an original_dst &lt;config_listener_filters_original_dst>`
    ///   :ref:`listener filter &lt;envoy_api_field_Listener.listener_filters>` instead.
    ///
    ///   Note that hand off to another listener is *NOT* performed without this flag. Once
    ///   :ref:`FilterChainMatch &lt;envoy_api_msg_listener.FilterChainMatch>` is implemented this flag
    ///   will be removed, as filter chain matching can be used to select a filter chain based on the
    ///   restored destination address.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool? UseOriginalDst {
      get { return useOriginalDst_; }
      set {
        useOriginalDst_ = value;
      }
    }

    /// <summary>Field number for the "per_connection_buffer_limit_bytes" field.</summary>
    public const int PerConnectionBufferLimitBytesFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_perConnectionBufferLimitBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? perConnectionBufferLimitBytes_;
    /// <summary>
    /// Soft limit on size of the listener’s new connection read and write buffers.
    /// If unspecified, an implementation defined default is applied (1MiB).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? PerConnectionBufferLimitBytes {
      get { return perConnectionBufferLimitBytes_; }
      set {
        perConnectionBufferLimitBytes_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 6;
    private global::Envoy.Api.V2.Core.Metadata metadata_;
    /// <summary>
    /// Listener metadata.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "deprecated_v1" field.</summary>
    public const int DeprecatedV1FieldNumber = 7;
    private global::Envoy.Api.V2.Listener.Types.DeprecatedV1 deprecatedV1_;
    /// <summary>
    /// [#not-implemented-hide:]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Listener.Types.DeprecatedV1 DeprecatedV1 {
      get { return deprecatedV1_; }
      set {
        deprecatedV1_ = value;
      }
    }

    /// <summary>Field number for the "drain_type" field.</summary>
    public const int DrainTypeFieldNumber = 8;
    private global::Envoy.Api.V2.Listener.Types.DrainType drainType_ = 0;
    /// <summary>
    /// The type of draining to perform at a listener-wide level.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Listener.Types.DrainType DrainType {
      get { return drainType_; }
      set {
        drainType_ = value;
      }
    }

    /// <summary>Field number for the "listener_filters" field.</summary>
    public const int ListenerFiltersFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Listener2.ListenerFilter> _repeated_listenerFilters_codec
        = pb::FieldCodec.ForMessage(74, global::Envoy.Api.V2.Listener2.ListenerFilter.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Listener2.ListenerFilter> listenerFilters_ = new pbc::RepeatedField<global::Envoy.Api.V2.Listener2.ListenerFilter>();
    /// <summary>
    /// Listener filters have the opportunity to manipulate and augment the connection metadata that
    /// is used in connection filter chain matching, for example. These filters are run before any in
    /// :ref:`filter_chains &lt;envoy_api_field_Listener.filter_chains>`. Order matters as the
    /// filters are processed sequentially right after a socket has been accepted by the listener, and
    /// before a connection is created.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Listener2.ListenerFilter> ListenerFilters {
      get { return listenerFilters_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Listener);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Listener other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Address, other.Address)) return false;
      if(!filterChains_.Equals(other.filterChains_)) return false;
      if (UseOriginalDst != other.UseOriginalDst) return false;
      if (PerConnectionBufferLimitBytes != other.PerConnectionBufferLimitBytes) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (!object.Equals(DeprecatedV1, other.DeprecatedV1)) return false;
      if (DrainType != other.DrainType) return false;
      if(!listenerFilters_.Equals(other.listenerFilters_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (address_ != null) hash ^= Address.GetHashCode();
      hash ^= filterChains_.GetHashCode();
      if (useOriginalDst_ != null) hash ^= UseOriginalDst.GetHashCode();
      if (perConnectionBufferLimitBytes_ != null) hash ^= PerConnectionBufferLimitBytes.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (deprecatedV1_ != null) hash ^= DeprecatedV1.GetHashCode();
      if (DrainType != 0) hash ^= DrainType.GetHashCode();
      hash ^= listenerFilters_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (address_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Address);
      }
      filterChains_.WriteTo(output, _repeated_filterChains_codec);
      if (useOriginalDst_ != null) {
        _single_useOriginalDst_codec.WriteTagAndValue(output, UseOriginalDst);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(output, PerConnectionBufferLimitBytes);
      }
      if (metadata_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Metadata);
      }
      if (deprecatedV1_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(DeprecatedV1);
      }
      if (DrainType != 0) {
        output.WriteRawTag(64);
        output.WriteEnum((int) DrainType);
      }
      listenerFilters_.WriteTo(output, _repeated_listenerFilters_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (address_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Address);
      }
      size += filterChains_.CalculateSize(_repeated_filterChains_codec);
      if (useOriginalDst_ != null) {
        size += _single_useOriginalDst_codec.CalculateSizeWithTag(UseOriginalDst);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        size += _single_perConnectionBufferLimitBytes_codec.CalculateSizeWithTag(PerConnectionBufferLimitBytes);
      }
      if (metadata_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (deprecatedV1_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeprecatedV1);
      }
      if (DrainType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DrainType);
      }
      size += listenerFilters_.CalculateSize(_repeated_listenerFilters_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Listener other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.address_ != null) {
        if (address_ == null) {
          address_ = new global::Envoy.Api.V2.Core.Address();
        }
        Address.MergeFrom(other.Address);
      }
      filterChains_.Add(other.filterChains_);
      if (other.useOriginalDst_ != null) {
        if (useOriginalDst_ == null || other.UseOriginalDst != false) {
          UseOriginalDst = other.UseOriginalDst;
        }
      }
      if (other.perConnectionBufferLimitBytes_ != null) {
        if (perConnectionBufferLimitBytes_ == null || other.PerConnectionBufferLimitBytes != 0) {
          PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
        }
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          metadata_ = new global::Envoy.Api.V2.Core.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.deprecatedV1_ != null) {
        if (deprecatedV1_ == null) {
          deprecatedV1_ = new global::Envoy.Api.V2.Listener.Types.DeprecatedV1();
        }
        DeprecatedV1.MergeFrom(other.DeprecatedV1);
      }
      if (other.DrainType != 0) {
        DrainType = other.DrainType;
      }
      listenerFilters_.Add(other.listenerFilters_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (address_ == null) {
              address_ = new global::Envoy.Api.V2.Core.Address();
            }
            input.ReadMessage(address_);
            break;
          }
          case 26: {
            filterChains_.AddEntriesFrom(input, _repeated_filterChains_codec);
            break;
          }
          case 34: {
            bool? value = _single_useOriginalDst_codec.Read(input);
            if (useOriginalDst_ == null || value != false) {
              UseOriginalDst = value;
            }
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 50: {
            if (metadata_ == null) {
              metadata_ = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(metadata_);
            break;
          }
          case 58: {
            if (deprecatedV1_ == null) {
              deprecatedV1_ = new global::Envoy.Api.V2.Listener.Types.DeprecatedV1();
            }
            input.ReadMessage(deprecatedV1_);
            break;
          }
          case 64: {
            drainType_ = (global::Envoy.Api.V2.Listener.Types.DrainType) input.ReadEnum();
            break;
          }
          case 74: {
            listenerFilters_.AddEntriesFrom(input, _repeated_listenerFilters_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Listener message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum DrainType {
        /// <summary>
        /// Drain in response to calling /healthcheck/fail admin endpoint (along with the health check
        /// filter), listener removal/modification, and hot restart.
        /// </summary>
        [pbr::OriginalName("DEFAULT")] Default = 0,
        /// <summary>
        /// Drain in response to listener removal/modification and hot restart. This setting does not
        /// include /healthcheck/fail. This setting may be desirable if Envoy is hosting both ingress
        /// and egress listeners.
        /// </summary>
        [pbr::OriginalName("MODIFY_ONLY")] ModifyOnly = 1,
      }

      /// <summary>
      /// [#not-implemented-hide:]
      /// </summary>
      public sealed partial class DeprecatedV1 : pb::IMessage<DeprecatedV1> {
        private static readonly pb::MessageParser<DeprecatedV1> _parser = new pb::MessageParser<DeprecatedV1>(() => new DeprecatedV1());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<DeprecatedV1> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Listener.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1(DeprecatedV1 other) : this() {
          BindToPort = other.BindToPort;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public DeprecatedV1 Clone() {
          return new DeprecatedV1(this);
        }

        /// <summary>Field number for the "bind_to_port" field.</summary>
        public const int BindToPortFieldNumber = 1;
        private static readonly pb::FieldCodec<bool?> _single_bindToPort_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
        private bool? bindToPort_;
        /// <summary>
        /// Whether the listener should bind to the port. A listener that doesn’t
        /// bind can only receive connections redirected from other listeners that
        /// set use_original_dst parameter to true. Default is true.
        ///
        /// [V2-API-DIFF] This is deprecated in v2, all Listeners will bind to their
        /// port. An additional filter chain must be created for every original
        /// destination port this listener may redirect to in v2, with the original
        /// port specified in the FilterChainMatch destination_port field.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool? BindToPort {
          get { return bindToPort_; }
          set {
            bindToPort_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as DeprecatedV1);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(DeprecatedV1 other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (BindToPort != other.BindToPort) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (bindToPort_ != null) hash ^= BindToPort.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (bindToPort_ != null) {
            _single_bindToPort_codec.WriteTagAndValue(output, BindToPort);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (bindToPort_ != null) {
            size += _single_bindToPort_codec.CalculateSizeWithTag(BindToPort);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(DeprecatedV1 other) {
          if (other == null) {
            return;
          }
          if (other.bindToPort_ != null) {
            if (bindToPort_ == null || other.BindToPort != false) {
              BindToPort = other.BindToPort;
            }
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                bool? value = _single_bindToPort_codec.Read(input);
                if (bindToPort_ == null || value != false) {
                  BindToPort = value;
                }
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
