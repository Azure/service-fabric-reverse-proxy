// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cds.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2 {

  /// <summary>Holder for reflection information generated from cds.proto</summary>
  public static partial class CdsReflection {

    #region Descriptor
    /// <summary>File descriptor for cds.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CdsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgljZHMucHJvdG8SDGVudm95LmFwaS52MhofZW52b3kvYXBpL3YyL2NvcmUv",
            "YWRkcmVzcy5wcm90bxocZW52b3kvYXBpL3YyL2F1dGgvY2VydC5wcm90bxoc",
            "ZW52b3kvYXBpL3YyL2NvcmUvYmFzZS5wcm90bxolZW52b3kvYXBpL3YyL2Nv",
            "cmUvY29uZmlnX3NvdXJjZS5wcm90bxocZW52b3kvYXBpL3YyL2Rpc2NvdmVy",
            "eS5wcm90bxokZW52b3kvYXBpL3YyL2NvcmUvaGVhbHRoX2NoZWNrLnByb3Rv",
            "GiBlbnZveS9hcGkvdjIvY29yZS9wcm90b2NvbC5wcm90bxoqZW52b3kvYXBp",
            "L3YyL2NsdXN0ZXIvY2lyY3VpdF9icmVha2VyLnByb3RvGixlbnZveS9hcGkv",
            "djIvY2x1c3Rlci9vdXRsaWVyX2RldGVjdGlvbi5wcm90bxocZ29vZ2xlL2Fw",
            "aS9hbm5vdGF0aW9ucy5wcm90bxoeZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9u",
            "LnByb3RvGhxnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvGh5nb29nbGUv",
            "cHJvdG9idWYvd3JhcHBlcnMucHJvdG8aF3ZhbGlkYXRlL3ZhbGlkYXRlLnBy",
            "b3RvGhRnb2dvcHJvdG8vZ29nby5wcm90byKzFgoHQ2x1c3RlchIXCgRuYW1l",
            "GAEgASgJQgm66cADBHICIAESFQoNYWx0X3N0YXRfbmFtZRgcIAEoCRI9CgR0",
            "eXBlGAIgASgOMiMuZW52b3kuYXBpLnYyLkNsdXN0ZXIuRGlzY292ZXJ5VHlw",
            "ZUIKuunAAwWCAQIQARJCChJlZHNfY2x1c3Rlcl9jb25maWcYAyABKAsyJi5l",
            "bnZveS5hcGkudjIuQ2x1c3Rlci5FZHNDbHVzdGVyQ29uZmlnEkYKD2Nvbm5l",
            "Y3RfdGltZW91dBgEIAEoCzIZLmdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbkIS",
            "uunAAwWqAQIqAJjfHwHI3h8AEkcKIXBlcl9jb25uZWN0aW9uX2J1ZmZlcl9s",
            "aW1pdF9ieXRlcxgFIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1",
            "ZRI9CglsYl9wb2xpY3kYBiABKA4yHi5lbnZveS5hcGkudjIuQ2x1c3Rlci5M",
            "YlBvbGljeUIKuunAAwWCAQIQARIpCgVob3N0cxgHIAMoCzIaLmVudm95LmFw",
            "aS52Mi5jb3JlLkFkZHJlc3MSNQoNaGVhbHRoX2NoZWNrcxgIIAMoCzIeLmVu",
            "dm95LmFwaS52Mi5jb3JlLkhlYWx0aENoZWNrEkEKG21heF9yZXF1ZXN0c19w",
            "ZXJfY29ubmVjdGlvbhgJIAEoCzIcLmdvb2dsZS5wcm90b2J1Zi5VSW50MzJW",
            "YWx1ZRJAChBjaXJjdWl0X2JyZWFrZXJzGAogASgLMiYuZW52b3kuYXBpLnYy",
            "LmNsdXN0ZXIyLkNpcmN1aXRCcmVha2VycxI6Cgt0bHNfY29udGV4dBgLIAEo",
            "CzIlLmVudm95LmFwaS52Mi5hdXRoLlVwc3RyZWFtVGxzQ29udGV4dBJGChVo",
            "dHRwX3Byb3RvY29sX29wdGlvbnMYDSABKAsyJy5lbnZveS5hcGkudjIuY29y",
            "ZS5IdHRwMVByb3RvY29sT3B0aW9ucxJHChZodHRwMl9wcm90b2NvbF9vcHRp",
            "b25zGA4gASgLMicuZW52b3kuYXBpLnYyLmNvcmUuSHR0cDJQcm90b2NvbE9w",
            "dGlvbnMSQwoQZG5zX3JlZnJlc2hfcmF0ZRgQIAEoCzIZLmdvb2dsZS5wcm90",
            "b2J1Zi5EdXJhdGlvbkIOuunAAwWqAQIqAJjfHwESTAoRZG5zX2xvb2t1cF9m",
            "YW1pbHkYESABKA4yJS5lbnZveS5hcGkudjIuQ2x1c3Rlci5EbnNMb29rdXBG",
            "YW1pbHlCCrrpwAMFggECEAESMQoNZG5zX3Jlc29sdmVycxgSIAMoCzIaLmVu",
            "dm95LmFwaS52Mi5jb3JlLkFkZHJlc3MSQgoRb3V0bGllcl9kZXRlY3Rpb24Y",
            "EyABKAsyJy5lbnZveS5hcGkudjIuY2x1c3RlcjIuT3V0bGllckRldGVjdGlv",
            "bhJDChBjbGVhbnVwX2ludGVydmFsGBQgASgLMhkuZ29vZ2xlLnByb3RvYnVm",
            "LkR1cmF0aW9uQg666cADBaoBAioAmN8fARI7ChR1cHN0cmVhbV9iaW5kX2Nv",
            "bmZpZxgVIAEoCzIdLmVudm95LmFwaS52Mi5jb3JlLkJpbmRDb25maWcSPgoQ",
            "bGJfc3Vic2V0X2NvbmZpZxgWIAEoCzIkLmVudm95LmFwaS52Mi5DbHVzdGVy",
            "LkxiU3Vic2V0Q29uZmlnEkUKE3JpbmdfaGFzaF9sYl9jb25maWcYFyABKAsy",
            "Ji5lbnZveS5hcGkudjIuQ2x1c3Rlci5SaW5nSGFzaExiQ29uZmlnSAASPgoQ",
            "Y29tbW9uX2xiX2NvbmZpZxgbIAEoCzIkLmVudm95LmFwaS52Mi5DbHVzdGVy",
            "LkNvbW1vbkxiQ29uZmlnEjwKEHRyYW5zcG9ydF9zb2NrZXQYGCABKAsyIi5l",
            "bnZveS5hcGkudjIuY29yZS5UcmFuc3BvcnRTb2NrZXQSLQoIbWV0YWRhdGEY",
            "GSABKAsyGy5lbnZveS5hcGkudjIuY29yZS5NZXRhZGF0YRJKChJwcm90b2Nv",
            "bF9zZWxlY3Rpb24YGiABKA4yLi5lbnZveS5hcGkudjIuQ2x1c3Rlci5DbHVz",
            "dGVyUHJvdG9jb2xTZWxlY3Rpb24aXQoQRWRzQ2x1c3RlckNvbmZpZxIzCgpl",
            "ZHNfY29uZmlnGAEgASgLMh8uZW52b3kuYXBpLnYyLmNvcmUuQ29uZmlnU291",
            "cmNlEhQKDHNlcnZpY2VfbmFtZRgCIAEoCRrnAgoOTGJTdWJzZXRDb25maWcS",
            "YAoPZmFsbGJhY2tfcG9saWN5GAEgASgOMjsuZW52b3kuYXBpLnYyLkNsdXN0",
            "ZXIuTGJTdWJzZXRDb25maWcuTGJTdWJzZXRGYWxsYmFja1BvbGljeUIKuunA",
            "AwWCAQIQARIvCg5kZWZhdWx0X3N1YnNldBgCIAEoCzIXLmdvb2dsZS5wcm90",
            "b2J1Zi5TdHJ1Y3QSTwoQc3Vic2V0X3NlbGVjdG9ycxgDIAMoCzI1LmVudm95",
            "LmFwaS52Mi5DbHVzdGVyLkxiU3Vic2V0Q29uZmlnLkxiU3Vic2V0U2VsZWN0",
            "b3IaIAoQTGJTdWJzZXRTZWxlY3RvchIMCgRrZXlzGAEgAygJIk8KFkxiU3Vi",
            "c2V0RmFsbGJhY2tQb2xpY3kSDwoLTk9fRkFMTEJBQ0sQABIQCgxBTllfRU5E",
            "UE9JTlQQARISCg5ERUZBVUxUX1NVQlNFVBACGt0BChBSaW5nSGFzaExiQ29u",
            "ZmlnEjcKEW1pbmltdW1fcmluZ19zaXplGAEgASgLMhwuZ29vZ2xlLnByb3Rv",
            "YnVmLlVJbnQ2NFZhbHVlEk4KDWRlcHJlY2F0ZWRfdjEYAiABKAsyMy5lbnZv",
            "eS5hcGkudjIuQ2x1c3Rlci5SaW5nSGFzaExiQ29uZmlnLkRlcHJlY2F0ZWRW",
            "MUICGAEaQAoMRGVwcmVjYXRlZFYxEjAKDHVzZV9zdGRfaGFzaBgBIAEoCzIa",
            "Lmdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUa0AEKDkNvbW1vbkxiQ29uZmln",
            "EjsKF2hlYWx0aHlfcGFuaWNfdGhyZXNob2xkGAEgASgLMhouZW52b3kuYXBp",
            "LnYyLmNvcmUuUGVyY2VudBqAAQoRWm9uZUF3YXJlTGJDb25maWcSMwoPcm91",
            "dGluZ19lbmFibGVkGAEgASgLMhouZW52b3kuYXBpLnYyLmNvcmUuUGVyY2Vu",
            "dBI2ChBtaW5fY2x1c3Rlcl9zaXplGAIgASgLMhwuZ29vZ2xlLnByb3RvYnVm",
            "LlVJbnQ2NFZhbHVlIlcKDURpc2NvdmVyeVR5cGUSCgoGU1RBVElDEAASDgoK",
            "U1RSSUNUX0ROUxABEg8KC0xPR0lDQUxfRE5TEAISBwoDRURTEAMSEAoMT1JJ",
            "R0lOQUxfRFNUEAQiagoITGJQb2xpY3kSDwoLUk9VTkRfUk9CSU4QABIRCg1M",
            "RUFTVF9SRVFVRVNUEAESDQoJUklOR19IQVNIEAISCgoGUkFORE9NEAMSEwoP",
            "T1JJR0lOQUxfRFNUX0xCEAQSCgoGTUFHTEVWEAUiNQoPRG5zTG9va3VwRmFt",
            "aWx5EggKBEFVVE8QABILCgdWNF9PTkxZEAESCwoHVjZfT05MWRACIlQKGENs",
            "dXN0ZXJQcm90b2NvbFNlbGVjdGlvbhIbChdVU0VfQ09ORklHVVJFRF9QUk9U",
            "T0NPTBAAEhsKF1VTRV9ET1dOU1RSRUFNX1BST1RPQ09MEAFCCwoJbGJfY29u",
            "ZmlnSgQIDBANSgQIDxAQIkgKElVwc3RyZWFtQmluZENvbmZpZxIyCg5zb3Vy",
            "Y2VfYWRkcmVzcxgBIAEoCzIaLmVudm95LmFwaS52Mi5jb3JlLkFkZHJlc3My",
            "5wEKF0NsdXN0ZXJEaXNjb3ZlcnlTZXJ2aWNlElcKDlN0cmVhbUNsdXN0ZXJz",
            "Eh4uZW52b3kuYXBpLnYyLkRpc2NvdmVyeVJlcXVlc3QaHy5lbnZveS5hcGku",
            "djIuRGlzY292ZXJ5UmVzcG9uc2UiACgBMAEScwoNRmV0Y2hDbHVzdGVycxIe",
            "LmVudm95LmFwaS52Mi5EaXNjb3ZlcnlSZXF1ZXN0Gh8uZW52b3kuYXBpLnYy",
            "LkRpc2NvdmVyeVJlc3BvbnNlIiGC0+STAhsiFi92Mi9kaXNjb3Zlcnk6Y2x1",
            "c3RlcnM6ASpCBKjiHgFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.AddressReflection.Descriptor, global::Envoy.Api.V2.Auth.CertReflection.Descriptor, global::Envoy.Api.V2.Core.BaseReflection.Descriptor, global::Envoy.Api.V2.Core.ConfigSourceReflection.Descriptor, global::Envoy.Api.V2.DiscoveryReflection.Descriptor, global::Envoy.Api.V2.Core.HealthCheckReflection.Descriptor, global::Envoy.Api.V2.Core.ProtocolReflection.Descriptor, global::Envoy.Api.V2.Cluster2.CircuitBreakerReflection.Descriptor, global::Envoy.Api.V2.Cluster2.OutlierDetectionReflection.Descriptor, global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.DurationReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.StructReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, global::Gogoproto.GogoReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster), global::Envoy.Api.V2.Cluster.Parser, new[]{ "Name", "AltStatName", "Type", "EdsClusterConfig", "ConnectTimeout", "PerConnectionBufferLimitBytes", "LbPolicy", "Hosts", "HealthChecks", "MaxRequestsPerConnection", "CircuitBreakers", "TlsContext", "HttpProtocolOptions", "Http2ProtocolOptions", "DnsRefreshRate", "DnsLookupFamily", "DnsResolvers", "OutlierDetection", "CleanupInterval", "UpstreamBindConfig", "LbSubsetConfig", "RingHashLbConfig", "CommonLbConfig", "TransportSocket", "Metadata", "ProtocolSelection" }, new[]{ "LbConfig" }, new[]{ typeof(global::Envoy.Api.V2.Cluster.Types.DiscoveryType), typeof(global::Envoy.Api.V2.Cluster.Types.LbPolicy), typeof(global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily), typeof(global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig), global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig.Parser, new[]{ "EdsConfig", "ServiceName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig), global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Parser, new[]{ "FallbackPolicy", "DefaultSubset", "SubsetSelectors" }, null, new[]{ typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector), global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Parser, new[]{ "Keys" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig), global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Parser, new[]{ "MinimumRingSize", "DeprecatedV1" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.DeprecatedV1), global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.DeprecatedV1.Parser, new[]{ "UseStdHash" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CommonLbConfig), global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Parser, new[]{ "HealthyPanicThreshold" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig), global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Types.ZoneAwareLbConfig.Parser, new[]{ "RoutingEnabled", "MinClusterSize" }, null, null, null)})}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.UpstreamBindConfig), global::Envoy.Api.V2.UpstreamBindConfig.Parser, new[]{ "SourceAddress" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration for a single upstream cluster.
  /// [#comment:next free field: 29]
  /// </summary>
  public sealed partial class Cluster : pb::IMessage<Cluster> {
    private static readonly pb::MessageParser<Cluster> _parser = new pb::MessageParser<Cluster>(() => new Cluster());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Cluster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.CdsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cluster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cluster(Cluster other) : this() {
      name_ = other.name_;
      altStatName_ = other.altStatName_;
      type_ = other.type_;
      EdsClusterConfig = other.edsClusterConfig_ != null ? other.EdsClusterConfig.Clone() : null;
      ConnectTimeout = other.connectTimeout_ != null ? other.ConnectTimeout.Clone() : null;
      PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
      lbPolicy_ = other.lbPolicy_;
      hosts_ = other.hosts_.Clone();
      healthChecks_ = other.healthChecks_.Clone();
      MaxRequestsPerConnection = other.MaxRequestsPerConnection;
      CircuitBreakers = other.circuitBreakers_ != null ? other.CircuitBreakers.Clone() : null;
      TlsContext = other.tlsContext_ != null ? other.TlsContext.Clone() : null;
      HttpProtocolOptions = other.httpProtocolOptions_ != null ? other.HttpProtocolOptions.Clone() : null;
      Http2ProtocolOptions = other.http2ProtocolOptions_ != null ? other.Http2ProtocolOptions.Clone() : null;
      DnsRefreshRate = other.dnsRefreshRate_ != null ? other.DnsRefreshRate.Clone() : null;
      dnsLookupFamily_ = other.dnsLookupFamily_;
      dnsResolvers_ = other.dnsResolvers_.Clone();
      OutlierDetection = other.outlierDetection_ != null ? other.OutlierDetection.Clone() : null;
      CleanupInterval = other.cleanupInterval_ != null ? other.CleanupInterval.Clone() : null;
      UpstreamBindConfig = other.upstreamBindConfig_ != null ? other.UpstreamBindConfig.Clone() : null;
      LbSubsetConfig = other.lbSubsetConfig_ != null ? other.LbSubsetConfig.Clone() : null;
      CommonLbConfig = other.commonLbConfig_ != null ? other.CommonLbConfig.Clone() : null;
      TransportSocket = other.transportSocket_ != null ? other.TransportSocket.Clone() : null;
      Metadata = other.metadata_ != null ? other.Metadata.Clone() : null;
      protocolSelection_ = other.protocolSelection_;
      switch (other.LbConfigCase) {
        case LbConfigOneofCase.RingHashLbConfig:
          RingHashLbConfig = other.RingHashLbConfig.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Cluster Clone() {
      return new Cluster(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Supplies the name of the cluster which must be unique across all clusters.
    /// The cluster name is used when emitting
    /// :ref:`statistics &lt;config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
    /// &lt;envoy_api_field_Cluster.alt_stat_name>` is not provided.
    /// Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
    /// By default, the maximum length of a cluster name is limited to 60
    /// characters. This limit can be increased by setting the
    /// :option:`--max-obj-name-len` command line argument to the desired value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "alt_stat_name" field.</summary>
    public const int AltStatNameFieldNumber = 28;
    private string altStatName_ = "";
    /// <summary>
    /// An optional alternative to the cluster name to be used while emitting stats.
    /// Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
    /// confused with :ref:`Router Filter Header
    /// &lt;config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AltStatName {
      get { return altStatName_; }
      set {
        altStatName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private global::Envoy.Api.V2.Cluster.Types.DiscoveryType type_ = 0;
    /// <summary>
    /// The :ref:`service discovery type &lt;arch_overview_service_discovery_types>`
    /// to use for resolving the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.DiscoveryType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "eds_cluster_config" field.</summary>
    public const int EdsClusterConfigFieldNumber = 3;
    private global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig edsClusterConfig_;
    /// <summary>
    /// Configuration to use for EDS updates for the Cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig EdsClusterConfig {
      get { return edsClusterConfig_; }
      set {
        edsClusterConfig_ = value;
      }
    }

    /// <summary>Field number for the "connect_timeout" field.</summary>
    public const int ConnectTimeoutFieldNumber = 4;
    private global::Google.Protobuf.WellKnownTypes.Duration connectTimeout_;
    /// <summary>
    /// The timeout for new network connections to hosts in the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration ConnectTimeout {
      get { return connectTimeout_; }
      set {
        connectTimeout_ = value;
      }
    }

    /// <summary>Field number for the "per_connection_buffer_limit_bytes" field.</summary>
    public const int PerConnectionBufferLimitBytesFieldNumber = 5;
    private static readonly pb::FieldCodec<uint?> _single_perConnectionBufferLimitBytes_codec = pb::FieldCodec.ForStructWrapper<uint>(42);
    private uint? perConnectionBufferLimitBytes_;
    /// <summary>
    /// Soft limit on size of the cluster’s connections read and write buffers. If
    /// unspecified, an implementation defined default is applied (1MiB).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? PerConnectionBufferLimitBytes {
      get { return perConnectionBufferLimitBytes_; }
      set {
        perConnectionBufferLimitBytes_ = value;
      }
    }

    /// <summary>Field number for the "lb_policy" field.</summary>
    public const int LbPolicyFieldNumber = 6;
    private global::Envoy.Api.V2.Cluster.Types.LbPolicy lbPolicy_ = 0;
    /// <summary>
    /// The :ref:`load balancer type &lt;arch_overview_load_balancing_types>` to use
    /// when picking a host in the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.LbPolicy LbPolicy {
      get { return lbPolicy_; }
      set {
        lbPolicy_ = value;
      }
    }

    /// <summary>Field number for the "hosts" field.</summary>
    public const int HostsFieldNumber = 7;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.Address> _repeated_hosts_codec
        = pb::FieldCodec.ForMessage(58, global::Envoy.Api.V2.Core.Address.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> hosts_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.Address>();
    /// <summary>
    /// If the service discovery type is
    /// :ref:`STATIC&lt;envoy_api_enum_value_Cluster.DiscoveryType.STATIC>`,
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// then hosts is required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> Hosts {
      get { return hosts_; }
    }

    /// <summary>Field number for the "health_checks" field.</summary>
    public const int HealthChecksFieldNumber = 8;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.HealthCheck> _repeated_healthChecks_codec
        = pb::FieldCodec.ForMessage(66, global::Envoy.Api.V2.Core.HealthCheck.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.HealthCheck> healthChecks_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.HealthCheck>();
    /// <summary>
    /// Optional :ref:`active health checking &lt;arch_overview_health_checking>`
    /// configuration for the cluster. If no
    /// configuration is specified no health checking will be done and all cluster
    /// members will be considered healthy at all times.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.HealthCheck> HealthChecks {
      get { return healthChecks_; }
    }

    /// <summary>Field number for the "max_requests_per_connection" field.</summary>
    public const int MaxRequestsPerConnectionFieldNumber = 9;
    private static readonly pb::FieldCodec<uint?> _single_maxRequestsPerConnection_codec = pb::FieldCodec.ForStructWrapper<uint>(74);
    private uint? maxRequestsPerConnection_;
    /// <summary>
    /// Optional maximum requests for a single upstream connection. This parameter
    /// is respected by both the HTTP/1.1 and HTTP/2 connection pool
    /// implementations. If not specified, there is no limit. Setting this
    /// parameter to 1 will effectively disable keep alive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? MaxRequestsPerConnection {
      get { return maxRequestsPerConnection_; }
      set {
        maxRequestsPerConnection_ = value;
      }
    }

    /// <summary>Field number for the "circuit_breakers" field.</summary>
    public const int CircuitBreakersFieldNumber = 10;
    private global::Envoy.Api.V2.Cluster2.CircuitBreakers circuitBreakers_;
    /// <summary>
    /// Optional :ref:`circuit breaking &lt;arch_overview_circuit_break>` for the cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster2.CircuitBreakers CircuitBreakers {
      get { return circuitBreakers_; }
      set {
        circuitBreakers_ = value;
      }
    }

    /// <summary>Field number for the "tls_context" field.</summary>
    public const int TlsContextFieldNumber = 11;
    private global::Envoy.Api.V2.Auth.UpstreamTlsContext tlsContext_;
    /// <summary>
    /// The TLS configuration for connections to the upstream cluster. If no TLS
    /// configuration is specified, TLS will not be used for new connections.
    ///
    /// .. attention::
    ///
    ///   Server certificate verification is not enabled by default. Configure
    ///   :ref:`trusted_ca&lt;envoy_api_field_auth.CertificateValidationContext.trusted_ca>` to enable
    ///   verification.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Auth.UpstreamTlsContext TlsContext {
      get { return tlsContext_; }
      set {
        tlsContext_ = value;
      }
    }

    /// <summary>Field number for the "http_protocol_options" field.</summary>
    public const int HttpProtocolOptionsFieldNumber = 13;
    private global::Envoy.Api.V2.Core.Http1ProtocolOptions httpProtocolOptions_;
    /// <summary>
    /// Additional options when handling HTTP1 requests.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Http1ProtocolOptions HttpProtocolOptions {
      get { return httpProtocolOptions_; }
      set {
        httpProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "http2_protocol_options" field.</summary>
    public const int Http2ProtocolOptionsFieldNumber = 14;
    private global::Envoy.Api.V2.Core.Http2ProtocolOptions http2ProtocolOptions_;
    /// <summary>
    /// Even if default HTTP2 protocol options are desired, this field must be
    /// set so that Envoy will assume that the upstream supports HTTP/2 when
    /// making new HTTP connection pool connections. Currently, Envoy only
    /// supports prior knowledge for upstream connections. Even if TLS is used
    /// with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
    /// connections to happen over plain text.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Http2ProtocolOptions Http2ProtocolOptions {
      get { return http2ProtocolOptions_; }
      set {
        http2ProtocolOptions_ = value;
      }
    }

    /// <summary>Field number for the "dns_refresh_rate" field.</summary>
    public const int DnsRefreshRateFieldNumber = 16;
    private global::Google.Protobuf.WellKnownTypes.Duration dnsRefreshRate_;
    /// <summary>
    /// If the DNS refresh rate is specified and the cluster type is either
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// this value is used as the cluster’s DNS refresh
    /// rate. If this setting is not specified, the value defaults to 5000. For
    /// cluster types other than
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration DnsRefreshRate {
      get { return dnsRefreshRate_; }
      set {
        dnsRefreshRate_ = value;
      }
    }

    /// <summary>Field number for the "dns_lookup_family" field.</summary>
    public const int DnsLookupFamilyFieldNumber = 17;
    private global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily dnsLookupFamily_ = 0;
    /// <summary>
    /// The DNS IP address resolution policy. If this setting is not specified, the
    /// value defaults to
    /// :ref:`AUTO&lt;envoy_api_enum_value_Cluster.DnsLookupFamily.AUTO>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily DnsLookupFamily {
      get { return dnsLookupFamily_; }
      set {
        dnsLookupFamily_ = value;
      }
    }

    /// <summary>Field number for the "dns_resolvers" field.</summary>
    public const int DnsResolversFieldNumber = 18;
    private static readonly pb::FieldCodec<global::Envoy.Api.V2.Core.Address> _repeated_dnsResolvers_codec
        = pb::FieldCodec.ForMessage(146, global::Envoy.Api.V2.Core.Address.Parser);
    private readonly pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> dnsResolvers_ = new pbc::RepeatedField<global::Envoy.Api.V2.Core.Address>();
    /// <summary>
    /// If DNS resolvers are specified and the cluster type is either
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`,
    /// or :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
    /// this value is used to specify the cluster’s dns resolvers.
    /// If this setting is not specified, the value defaults to the default
    /// resolver, which uses /etc/resolv.conf for configuration. For cluster types
    /// other than
    /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>`
    /// and :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Envoy.Api.V2.Core.Address> DnsResolvers {
      get { return dnsResolvers_; }
    }

    /// <summary>Field number for the "outlier_detection" field.</summary>
    public const int OutlierDetectionFieldNumber = 19;
    private global::Envoy.Api.V2.Cluster2.OutlierDetection outlierDetection_;
    /// <summary>
    /// If specified, outlier detection will be enabled for this upstream cluster.
    /// Each of the configuration values can be overridden via
    /// :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_outlier_detection>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster2.OutlierDetection OutlierDetection {
      get { return outlierDetection_; }
      set {
        outlierDetection_ = value;
      }
    }

    /// <summary>Field number for the "cleanup_interval" field.</summary>
    public const int CleanupIntervalFieldNumber = 20;
    private global::Google.Protobuf.WellKnownTypes.Duration cleanupInterval_;
    /// <summary>
    /// The interval for removing stale hosts from a cluster type
    /// :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`.
    /// Hosts are considered stale if they have not been used
    /// as upstream destinations during this interval. New hosts are added
    /// to original destination clusters on demand as new connections are
    /// redirected to Envoy, causing the number of hosts in the cluster to
    /// grow over time. Hosts that are not stale (they are actively used as
    /// destinations) are kept in the cluster, which allows connections to
    /// them remain open, saving the latency that would otherwise be spent
    /// on opening new connections. If this setting is not specified, the
    /// value defaults to 5000ms. For cluster types other than
    /// :ref:`ORIGINAL_DST&lt;envoy_api_enum_value_Cluster.DiscoveryType.ORIGINAL_DST>`
    /// this setting is ignored.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Duration CleanupInterval {
      get { return cleanupInterval_; }
      set {
        cleanupInterval_ = value;
      }
    }

    /// <summary>Field number for the "upstream_bind_config" field.</summary>
    public const int UpstreamBindConfigFieldNumber = 21;
    private global::Envoy.Api.V2.Core.BindConfig upstreamBindConfig_;
    /// <summary>
    /// Optional configuration used to bind newly established upstream connections.
    /// This overrides any bind_config specified in the bootstrap proto.
    /// If the addres and port are empty, no bind will be performed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.BindConfig UpstreamBindConfig {
      get { return upstreamBindConfig_; }
      set {
        upstreamBindConfig_ = value;
      }
    }

    /// <summary>Field number for the "lb_subset_config" field.</summary>
    public const int LbSubsetConfigFieldNumber = 22;
    private global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig lbSubsetConfig_;
    /// <summary>
    /// Configuration for load balancing subsetting.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig LbSubsetConfig {
      get { return lbSubsetConfig_; }
      set {
        lbSubsetConfig_ = value;
      }
    }

    /// <summary>Field number for the "ring_hash_lb_config" field.</summary>
    public const int RingHashLbConfigFieldNumber = 23;
    /// <summary>
    /// Optional configuration for the Ring Hash load balancing policy.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig RingHashLbConfig {
      get { return lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig ? (global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig) lbConfig_ : null; }
      set {
        lbConfig_ = value;
        lbConfigCase_ = value == null ? LbConfigOneofCase.None : LbConfigOneofCase.RingHashLbConfig;
      }
    }

    /// <summary>Field number for the "common_lb_config" field.</summary>
    public const int CommonLbConfigFieldNumber = 27;
    private global::Envoy.Api.V2.Cluster.Types.CommonLbConfig commonLbConfig_;
    /// <summary>
    /// Common configuration for all load balancer implementations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.CommonLbConfig CommonLbConfig {
      get { return commonLbConfig_; }
      set {
        commonLbConfig_ = value;
      }
    }

    /// <summary>Field number for the "transport_socket" field.</summary>
    public const int TransportSocketFieldNumber = 24;
    private global::Envoy.Api.V2.Core.TransportSocket transportSocket_;
    /// <summary>
    /// Optional custom transport socket implementation to use for upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.TransportSocket TransportSocket {
      get { return transportSocket_; }
      set {
        transportSocket_ = value;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 25;
    private global::Envoy.Api.V2.Core.Metadata metadata_;
    /// <summary>
    /// The Metadata field can be used to provide additional information about the
    /// cluster. It can be used for stats, logging, and varying filter behavior.
    /// Fields should use reverse DNS notation to denote which entity within Envoy
    /// will need the information. For instance, if the metadata is intended for
    /// the Router filter, the filter name should be specified as *envoy.router*.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Metadata Metadata {
      get { return metadata_; }
      set {
        metadata_ = value;
      }
    }

    /// <summary>Field number for the "protocol_selection" field.</summary>
    public const int ProtocolSelectionFieldNumber = 26;
    private global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection protocolSelection_ = 0;
    /// <summary>
    /// Determines how Envoy selects the protocol used to speak to upstream hosts.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection ProtocolSelection {
      get { return protocolSelection_; }
      set {
        protocolSelection_ = value;
      }
    }

    private object lbConfig_;
    /// <summary>Enum of possible cases for the "lb_config" oneof.</summary>
    public enum LbConfigOneofCase {
      None = 0,
      RingHashLbConfig = 23,
    }
    private LbConfigOneofCase lbConfigCase_ = LbConfigOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LbConfigOneofCase LbConfigCase {
      get { return lbConfigCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLbConfig() {
      lbConfigCase_ = LbConfigOneofCase.None;
      lbConfig_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Cluster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Cluster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (AltStatName != other.AltStatName) return false;
      if (Type != other.Type) return false;
      if (!object.Equals(EdsClusterConfig, other.EdsClusterConfig)) return false;
      if (!object.Equals(ConnectTimeout, other.ConnectTimeout)) return false;
      if (PerConnectionBufferLimitBytes != other.PerConnectionBufferLimitBytes) return false;
      if (LbPolicy != other.LbPolicy) return false;
      if(!hosts_.Equals(other.hosts_)) return false;
      if(!healthChecks_.Equals(other.healthChecks_)) return false;
      if (MaxRequestsPerConnection != other.MaxRequestsPerConnection) return false;
      if (!object.Equals(CircuitBreakers, other.CircuitBreakers)) return false;
      if (!object.Equals(TlsContext, other.TlsContext)) return false;
      if (!object.Equals(HttpProtocolOptions, other.HttpProtocolOptions)) return false;
      if (!object.Equals(Http2ProtocolOptions, other.Http2ProtocolOptions)) return false;
      if (!object.Equals(DnsRefreshRate, other.DnsRefreshRate)) return false;
      if (DnsLookupFamily != other.DnsLookupFamily) return false;
      if(!dnsResolvers_.Equals(other.dnsResolvers_)) return false;
      if (!object.Equals(OutlierDetection, other.OutlierDetection)) return false;
      if (!object.Equals(CleanupInterval, other.CleanupInterval)) return false;
      if (!object.Equals(UpstreamBindConfig, other.UpstreamBindConfig)) return false;
      if (!object.Equals(LbSubsetConfig, other.LbSubsetConfig)) return false;
      if (!object.Equals(RingHashLbConfig, other.RingHashLbConfig)) return false;
      if (!object.Equals(CommonLbConfig, other.CommonLbConfig)) return false;
      if (!object.Equals(TransportSocket, other.TransportSocket)) return false;
      if (!object.Equals(Metadata, other.Metadata)) return false;
      if (ProtocolSelection != other.ProtocolSelection) return false;
      if (LbConfigCase != other.LbConfigCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (AltStatName.Length != 0) hash ^= AltStatName.GetHashCode();
      if (Type != 0) hash ^= Type.GetHashCode();
      if (edsClusterConfig_ != null) hash ^= EdsClusterConfig.GetHashCode();
      if (connectTimeout_ != null) hash ^= ConnectTimeout.GetHashCode();
      if (perConnectionBufferLimitBytes_ != null) hash ^= PerConnectionBufferLimitBytes.GetHashCode();
      if (LbPolicy != 0) hash ^= LbPolicy.GetHashCode();
      hash ^= hosts_.GetHashCode();
      hash ^= healthChecks_.GetHashCode();
      if (maxRequestsPerConnection_ != null) hash ^= MaxRequestsPerConnection.GetHashCode();
      if (circuitBreakers_ != null) hash ^= CircuitBreakers.GetHashCode();
      if (tlsContext_ != null) hash ^= TlsContext.GetHashCode();
      if (httpProtocolOptions_ != null) hash ^= HttpProtocolOptions.GetHashCode();
      if (http2ProtocolOptions_ != null) hash ^= Http2ProtocolOptions.GetHashCode();
      if (dnsRefreshRate_ != null) hash ^= DnsRefreshRate.GetHashCode();
      if (DnsLookupFamily != 0) hash ^= DnsLookupFamily.GetHashCode();
      hash ^= dnsResolvers_.GetHashCode();
      if (outlierDetection_ != null) hash ^= OutlierDetection.GetHashCode();
      if (cleanupInterval_ != null) hash ^= CleanupInterval.GetHashCode();
      if (upstreamBindConfig_ != null) hash ^= UpstreamBindConfig.GetHashCode();
      if (lbSubsetConfig_ != null) hash ^= LbSubsetConfig.GetHashCode();
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) hash ^= RingHashLbConfig.GetHashCode();
      if (commonLbConfig_ != null) hash ^= CommonLbConfig.GetHashCode();
      if (transportSocket_ != null) hash ^= TransportSocket.GetHashCode();
      if (metadata_ != null) hash ^= Metadata.GetHashCode();
      if (ProtocolSelection != 0) hash ^= ProtocolSelection.GetHashCode();
      hash ^= (int) lbConfigCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Type != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) Type);
      }
      if (edsClusterConfig_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(EdsClusterConfig);
      }
      if (connectTimeout_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ConnectTimeout);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        _single_perConnectionBufferLimitBytes_codec.WriteTagAndValue(output, PerConnectionBufferLimitBytes);
      }
      if (LbPolicy != 0) {
        output.WriteRawTag(48);
        output.WriteEnum((int) LbPolicy);
      }
      hosts_.WriteTo(output, _repeated_hosts_codec);
      healthChecks_.WriteTo(output, _repeated_healthChecks_codec);
      if (maxRequestsPerConnection_ != null) {
        _single_maxRequestsPerConnection_codec.WriteTagAndValue(output, MaxRequestsPerConnection);
      }
      if (circuitBreakers_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(CircuitBreakers);
      }
      if (tlsContext_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(TlsContext);
      }
      if (httpProtocolOptions_ != null) {
        output.WriteRawTag(106);
        output.WriteMessage(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        output.WriteRawTag(114);
        output.WriteMessage(Http2ProtocolOptions);
      }
      if (dnsRefreshRate_ != null) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(DnsRefreshRate);
      }
      if (DnsLookupFamily != 0) {
        output.WriteRawTag(136, 1);
        output.WriteEnum((int) DnsLookupFamily);
      }
      dnsResolvers_.WriteTo(output, _repeated_dnsResolvers_codec);
      if (outlierDetection_ != null) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(OutlierDetection);
      }
      if (cleanupInterval_ != null) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(CleanupInterval);
      }
      if (upstreamBindConfig_ != null) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(UpstreamBindConfig);
      }
      if (lbSubsetConfig_ != null) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(LbSubsetConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(RingHashLbConfig);
      }
      if (transportSocket_ != null) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(TransportSocket);
      }
      if (metadata_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(Metadata);
      }
      if (ProtocolSelection != 0) {
        output.WriteRawTag(208, 1);
        output.WriteEnum((int) ProtocolSelection);
      }
      if (commonLbConfig_ != null) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(CommonLbConfig);
      }
      if (AltStatName.Length != 0) {
        output.WriteRawTag(226, 1);
        output.WriteString(AltStatName);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (AltStatName.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(AltStatName);
      }
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (edsClusterConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EdsClusterConfig);
      }
      if (connectTimeout_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConnectTimeout);
      }
      if (perConnectionBufferLimitBytes_ != null) {
        size += _single_perConnectionBufferLimitBytes_codec.CalculateSizeWithTag(PerConnectionBufferLimitBytes);
      }
      if (LbPolicy != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LbPolicy);
      }
      size += hosts_.CalculateSize(_repeated_hosts_codec);
      size += healthChecks_.CalculateSize(_repeated_healthChecks_codec);
      if (maxRequestsPerConnection_ != null) {
        size += _single_maxRequestsPerConnection_codec.CalculateSizeWithTag(MaxRequestsPerConnection);
      }
      if (circuitBreakers_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CircuitBreakers);
      }
      if (tlsContext_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TlsContext);
      }
      if (httpProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HttpProtocolOptions);
      }
      if (http2ProtocolOptions_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http2ProtocolOptions);
      }
      if (dnsRefreshRate_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DnsRefreshRate);
      }
      if (DnsLookupFamily != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) DnsLookupFamily);
      }
      size += dnsResolvers_.CalculateSize(_repeated_dnsResolvers_codec);
      if (outlierDetection_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(OutlierDetection);
      }
      if (cleanupInterval_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CleanupInterval);
      }
      if (upstreamBindConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(UpstreamBindConfig);
      }
      if (lbSubsetConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(LbSubsetConfig);
      }
      if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RingHashLbConfig);
      }
      if (commonLbConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(CommonLbConfig);
      }
      if (transportSocket_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(TransportSocket);
      }
      if (metadata_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Metadata);
      }
      if (ProtocolSelection != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ProtocolSelection);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Cluster other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.AltStatName.Length != 0) {
        AltStatName = other.AltStatName;
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      if (other.edsClusterConfig_ != null) {
        if (edsClusterConfig_ == null) {
          edsClusterConfig_ = new global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig();
        }
        EdsClusterConfig.MergeFrom(other.EdsClusterConfig);
      }
      if (other.connectTimeout_ != null) {
        if (connectTimeout_ == null) {
          connectTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        ConnectTimeout.MergeFrom(other.ConnectTimeout);
      }
      if (other.perConnectionBufferLimitBytes_ != null) {
        if (perConnectionBufferLimitBytes_ == null || other.PerConnectionBufferLimitBytes != 0) {
          PerConnectionBufferLimitBytes = other.PerConnectionBufferLimitBytes;
        }
      }
      if (other.LbPolicy != 0) {
        LbPolicy = other.LbPolicy;
      }
      hosts_.Add(other.hosts_);
      healthChecks_.Add(other.healthChecks_);
      if (other.maxRequestsPerConnection_ != null) {
        if (maxRequestsPerConnection_ == null || other.MaxRequestsPerConnection != 0) {
          MaxRequestsPerConnection = other.MaxRequestsPerConnection;
        }
      }
      if (other.circuitBreakers_ != null) {
        if (circuitBreakers_ == null) {
          circuitBreakers_ = new global::Envoy.Api.V2.Cluster2.CircuitBreakers();
        }
        CircuitBreakers.MergeFrom(other.CircuitBreakers);
      }
      if (other.tlsContext_ != null) {
        if (tlsContext_ == null) {
          tlsContext_ = new global::Envoy.Api.V2.Auth.UpstreamTlsContext();
        }
        TlsContext.MergeFrom(other.TlsContext);
      }
      if (other.httpProtocolOptions_ != null) {
        if (httpProtocolOptions_ == null) {
          httpProtocolOptions_ = new global::Envoy.Api.V2.Core.Http1ProtocolOptions();
        }
        HttpProtocolOptions.MergeFrom(other.HttpProtocolOptions);
      }
      if (other.http2ProtocolOptions_ != null) {
        if (http2ProtocolOptions_ == null) {
          http2ProtocolOptions_ = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
        }
        Http2ProtocolOptions.MergeFrom(other.Http2ProtocolOptions);
      }
      if (other.dnsRefreshRate_ != null) {
        if (dnsRefreshRate_ == null) {
          dnsRefreshRate_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        DnsRefreshRate.MergeFrom(other.DnsRefreshRate);
      }
      if (other.DnsLookupFamily != 0) {
        DnsLookupFamily = other.DnsLookupFamily;
      }
      dnsResolvers_.Add(other.dnsResolvers_);
      if (other.outlierDetection_ != null) {
        if (outlierDetection_ == null) {
          outlierDetection_ = new global::Envoy.Api.V2.Cluster2.OutlierDetection();
        }
        OutlierDetection.MergeFrom(other.OutlierDetection);
      }
      if (other.cleanupInterval_ != null) {
        if (cleanupInterval_ == null) {
          cleanupInterval_ = new global::Google.Protobuf.WellKnownTypes.Duration();
        }
        CleanupInterval.MergeFrom(other.CleanupInterval);
      }
      if (other.upstreamBindConfig_ != null) {
        if (upstreamBindConfig_ == null) {
          upstreamBindConfig_ = new global::Envoy.Api.V2.Core.BindConfig();
        }
        UpstreamBindConfig.MergeFrom(other.UpstreamBindConfig);
      }
      if (other.lbSubsetConfig_ != null) {
        if (lbSubsetConfig_ == null) {
          lbSubsetConfig_ = new global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig();
        }
        LbSubsetConfig.MergeFrom(other.LbSubsetConfig);
      }
      if (other.commonLbConfig_ != null) {
        if (commonLbConfig_ == null) {
          commonLbConfig_ = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig();
        }
        CommonLbConfig.MergeFrom(other.CommonLbConfig);
      }
      if (other.transportSocket_ != null) {
        if (transportSocket_ == null) {
          transportSocket_ = new global::Envoy.Api.V2.Core.TransportSocket();
        }
        TransportSocket.MergeFrom(other.TransportSocket);
      }
      if (other.metadata_ != null) {
        if (metadata_ == null) {
          metadata_ = new global::Envoy.Api.V2.Core.Metadata();
        }
        Metadata.MergeFrom(other.Metadata);
      }
      if (other.ProtocolSelection != 0) {
        ProtocolSelection = other.ProtocolSelection;
      }
      switch (other.LbConfigCase) {
        case LbConfigOneofCase.RingHashLbConfig:
          if (RingHashLbConfig == null) {
            RingHashLbConfig = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig();
          }
          RingHashLbConfig.MergeFrom(other.RingHashLbConfig);
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 16: {
            type_ = (global::Envoy.Api.V2.Cluster.Types.DiscoveryType) input.ReadEnum();
            break;
          }
          case 26: {
            if (edsClusterConfig_ == null) {
              edsClusterConfig_ = new global::Envoy.Api.V2.Cluster.Types.EdsClusterConfig();
            }
            input.ReadMessage(edsClusterConfig_);
            break;
          }
          case 34: {
            if (connectTimeout_ == null) {
              connectTimeout_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(connectTimeout_);
            break;
          }
          case 42: {
            uint? value = _single_perConnectionBufferLimitBytes_codec.Read(input);
            if (perConnectionBufferLimitBytes_ == null || value != 0) {
              PerConnectionBufferLimitBytes = value;
            }
            break;
          }
          case 48: {
            lbPolicy_ = (global::Envoy.Api.V2.Cluster.Types.LbPolicy) input.ReadEnum();
            break;
          }
          case 58: {
            hosts_.AddEntriesFrom(input, _repeated_hosts_codec);
            break;
          }
          case 66: {
            healthChecks_.AddEntriesFrom(input, _repeated_healthChecks_codec);
            break;
          }
          case 74: {
            uint? value = _single_maxRequestsPerConnection_codec.Read(input);
            if (maxRequestsPerConnection_ == null || value != 0) {
              MaxRequestsPerConnection = value;
            }
            break;
          }
          case 82: {
            if (circuitBreakers_ == null) {
              circuitBreakers_ = new global::Envoy.Api.V2.Cluster2.CircuitBreakers();
            }
            input.ReadMessage(circuitBreakers_);
            break;
          }
          case 90: {
            if (tlsContext_ == null) {
              tlsContext_ = new global::Envoy.Api.V2.Auth.UpstreamTlsContext();
            }
            input.ReadMessage(tlsContext_);
            break;
          }
          case 106: {
            if (httpProtocolOptions_ == null) {
              httpProtocolOptions_ = new global::Envoy.Api.V2.Core.Http1ProtocolOptions();
            }
            input.ReadMessage(httpProtocolOptions_);
            break;
          }
          case 114: {
            if (http2ProtocolOptions_ == null) {
              http2ProtocolOptions_ = new global::Envoy.Api.V2.Core.Http2ProtocolOptions();
            }
            input.ReadMessage(http2ProtocolOptions_);
            break;
          }
          case 130: {
            if (dnsRefreshRate_ == null) {
              dnsRefreshRate_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(dnsRefreshRate_);
            break;
          }
          case 136: {
            dnsLookupFamily_ = (global::Envoy.Api.V2.Cluster.Types.DnsLookupFamily) input.ReadEnum();
            break;
          }
          case 146: {
            dnsResolvers_.AddEntriesFrom(input, _repeated_dnsResolvers_codec);
            break;
          }
          case 154: {
            if (outlierDetection_ == null) {
              outlierDetection_ = new global::Envoy.Api.V2.Cluster2.OutlierDetection();
            }
            input.ReadMessage(outlierDetection_);
            break;
          }
          case 162: {
            if (cleanupInterval_ == null) {
              cleanupInterval_ = new global::Google.Protobuf.WellKnownTypes.Duration();
            }
            input.ReadMessage(cleanupInterval_);
            break;
          }
          case 170: {
            if (upstreamBindConfig_ == null) {
              upstreamBindConfig_ = new global::Envoy.Api.V2.Core.BindConfig();
            }
            input.ReadMessage(upstreamBindConfig_);
            break;
          }
          case 178: {
            if (lbSubsetConfig_ == null) {
              lbSubsetConfig_ = new global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig();
            }
            input.ReadMessage(lbSubsetConfig_);
            break;
          }
          case 186: {
            global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig subBuilder = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig();
            if (lbConfigCase_ == LbConfigOneofCase.RingHashLbConfig) {
              subBuilder.MergeFrom(RingHashLbConfig);
            }
            input.ReadMessage(subBuilder);
            RingHashLbConfig = subBuilder;
            break;
          }
          case 194: {
            if (transportSocket_ == null) {
              transportSocket_ = new global::Envoy.Api.V2.Core.TransportSocket();
            }
            input.ReadMessage(transportSocket_);
            break;
          }
          case 202: {
            if (metadata_ == null) {
              metadata_ = new global::Envoy.Api.V2.Core.Metadata();
            }
            input.ReadMessage(metadata_);
            break;
          }
          case 208: {
            protocolSelection_ = (global::Envoy.Api.V2.Cluster.Types.ClusterProtocolSelection) input.ReadEnum();
            break;
          }
          case 218: {
            if (commonLbConfig_ == null) {
              commonLbConfig_ = new global::Envoy.Api.V2.Cluster.Types.CommonLbConfig();
            }
            input.ReadMessage(commonLbConfig_);
            break;
          }
          case 226: {
            AltStatName = input.ReadString();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Cluster message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Refer to :ref:`service discovery type &lt;arch_overview_service_discovery_types>`
      /// for an explanation on each type.
      /// </summary>
      public enum DiscoveryType {
        /// <summary>
        /// Refer to the :ref:`static discovery type&lt;arch_overview_service_discovery_types_static>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("STATIC")] Static = 0,
        /// <summary>
        /// Refer to the :ref:`strict DNS discovery
        /// type&lt;arch_overview_service_discovery_types_strict_dns>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("STRICT_DNS")] StrictDns = 1,
        /// <summary>
        /// Refer to the :ref:`logical DNS discovery
        /// type&lt;arch_overview_service_discovery_types_logical_dns>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("LOGICAL_DNS")] LogicalDns = 2,
        /// <summary>
        /// Refer to the :ref:`service discovery type&lt;arch_overview_service_discovery_types_sds>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("EDS")] Eds = 3,
        /// <summary>
        /// Refer to the :ref:`original destination discovery
        /// type&lt;arch_overview_service_discovery_types_original_destination>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("ORIGINAL_DST")] OriginalDst = 4,
      }

      /// <summary>
      /// Refer to :ref:`load balancer type &lt;arch_overview_load_balancing_types>` architecture
      /// overview section for information on each type.
      /// </summary>
      public enum LbPolicy {
        /// <summary>
        /// Refer to the :ref:`round robin load balancing
        /// policy&lt;arch_overview_load_balancing_types_round_robin>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("ROUND_ROBIN")] RoundRobin = 0,
        /// <summary>
        /// Refer to the :ref:`least request load balancing
        /// policy&lt;arch_overview_load_balancing_types_least_request>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("LEAST_REQUEST")] LeastRequest = 1,
        /// <summary>
        /// Refer to the :ref:`ring hash load balancing
        /// policy&lt;arch_overview_load_balancing_types_ring_hash>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("RING_HASH")] RingHash = 2,
        /// <summary>
        /// Refer to the :ref:`random load balancing
        /// policy&lt;arch_overview_load_balancing_types_random>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("RANDOM")] Random = 3,
        /// <summary>
        /// Refer to the :ref:`original destination load balancing
        /// policy&lt;arch_overview_load_balancing_types_original_destination>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("ORIGINAL_DST_LB")] OriginalDstLb = 4,
        /// <summary>
        /// Refer to the :ref:`Maglev load balancing policy&lt;arch_overview_load_balancing_types_maglev>`
        /// for an explanation.
        /// </summary>
        [pbr::OriginalName("MAGLEV")] Maglev = 5,
      }

      /// <summary>
      /// When V4_ONLY is selected, the DNS resolver will only perform a lookup for
      /// addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
      /// only perform a lookup for addresses in the IPv6 family. If AUTO is
      /// specified, the DNS resolver will first perform a lookup for addresses in
      /// the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
      /// For cluster types other than
      /// :ref:`STRICT_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.STRICT_DNS>` and
      /// :ref:`LOGICAL_DNS&lt;envoy_api_enum_value_Cluster.DiscoveryType.LOGICAL_DNS>`,
      /// this setting is
      /// ignored.
      /// </summary>
      public enum DnsLookupFamily {
        [pbr::OriginalName("AUTO")] Auto = 0,
        [pbr::OriginalName("V4_ONLY")] V4Only = 1,
        [pbr::OriginalName("V6_ONLY")] V6Only = 2,
      }

      public enum ClusterProtocolSelection {
        /// <summary>
        /// Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
        /// If :ref:`http2_protocol_options &lt;envoy_api_field_Cluster.http2_protocol_options>` are
        /// present, HTTP2 will be used, otherwise HTTP1.1 will be used.
        /// </summary>
        [pbr::OriginalName("USE_CONFIGURED_PROTOCOL")] UseConfiguredProtocol = 0,
        /// <summary>
        /// Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
        /// </summary>
        [pbr::OriginalName("USE_DOWNSTREAM_PROTOCOL")] UseDownstreamProtocol = 1,
      }

      /// <summary>
      /// Only valid when discovery type is EDS.
      /// </summary>
      public sealed partial class EdsClusterConfig : pb::IMessage<EdsClusterConfig> {
        private static readonly pb::MessageParser<EdsClusterConfig> _parser = new pb::MessageParser<EdsClusterConfig>(() => new EdsClusterConfig());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<EdsClusterConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EdsClusterConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EdsClusterConfig(EdsClusterConfig other) : this() {
          EdsConfig = other.edsConfig_ != null ? other.EdsConfig.Clone() : null;
          serviceName_ = other.serviceName_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EdsClusterConfig Clone() {
          return new EdsClusterConfig(this);
        }

        /// <summary>Field number for the "eds_config" field.</summary>
        public const int EdsConfigFieldNumber = 1;
        private global::Envoy.Api.V2.Core.ConfigSource edsConfig_;
        /// <summary>
        /// Configuration for the source of EDS updates for this Cluster.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Core.ConfigSource EdsConfig {
          get { return edsConfig_; }
          set {
            edsConfig_ = value;
          }
        }

        /// <summary>Field number for the "service_name" field.</summary>
        public const int ServiceNameFieldNumber = 2;
        private string serviceName_ = "";
        /// <summary>
        /// Optional alternative to cluster name to present to EDS. This does not
        /// have the same restrictions as cluster name, i.e. it may be arbitrary
        /// length.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string ServiceName {
          get { return serviceName_; }
          set {
            serviceName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as EdsClusterConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(EdsClusterConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(EdsConfig, other.EdsConfig)) return false;
          if (ServiceName != other.ServiceName) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (edsConfig_ != null) hash ^= EdsConfig.GetHashCode();
          if (ServiceName.Length != 0) hash ^= ServiceName.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (edsConfig_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(EdsConfig);
          }
          if (ServiceName.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(ServiceName);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (edsConfig_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(EdsConfig);
          }
          if (ServiceName.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(ServiceName);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(EdsClusterConfig other) {
          if (other == null) {
            return;
          }
          if (other.edsConfig_ != null) {
            if (edsConfig_ == null) {
              edsConfig_ = new global::Envoy.Api.V2.Core.ConfigSource();
            }
            EdsConfig.MergeFrom(other.EdsConfig);
          }
          if (other.ServiceName.Length != 0) {
            ServiceName = other.ServiceName;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                if (edsConfig_ == null) {
                  edsConfig_ = new global::Envoy.Api.V2.Core.ConfigSource();
                }
                input.ReadMessage(edsConfig_);
                break;
              }
              case 18: {
                ServiceName = input.ReadString();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Optionally divide the endpoints in this cluster into subsets defined by
      /// endpoint metadata and selected by route and weighted cluster metadata.
      /// </summary>
      public sealed partial class LbSubsetConfig : pb::IMessage<LbSubsetConfig> {
        private static readonly pb::MessageParser<LbSubsetConfig> _parser = new pb::MessageParser<LbSubsetConfig>(() => new LbSubsetConfig());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<LbSubsetConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LbSubsetConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LbSubsetConfig(LbSubsetConfig other) : this() {
          fallbackPolicy_ = other.fallbackPolicy_;
          DefaultSubset = other.defaultSubset_ != null ? other.DefaultSubset.Clone() : null;
          subsetSelectors_ = other.subsetSelectors_.Clone();
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public LbSubsetConfig Clone() {
          return new LbSubsetConfig(this);
        }

        /// <summary>Field number for the "fallback_policy" field.</summary>
        public const int FallbackPolicyFieldNumber = 1;
        private global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy fallbackPolicy_ = 0;
        /// <summary>
        /// The behavior used when no endpoint subset matches the selected route's
        /// metadata. The value defaults to
        /// :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy FallbackPolicy {
          get { return fallbackPolicy_; }
          set {
            fallbackPolicy_ = value;
          }
        }

        /// <summary>Field number for the "default_subset" field.</summary>
        public const int DefaultSubsetFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Struct defaultSubset_;
        /// <summary>
        /// Specifies the default subset of endpoints used during fallback if
        /// fallback_policy is
        /// :ref:`DEFAULT_SUBSET&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
        /// Each field in default_subset is
        /// compared to the matching LbEndpoint.Metadata under the *envoy.lb*
        /// namespace. It is valid for no hosts to match, in which case the behavior
        /// is the same as a fallback_policy of
        /// :ref:`NO_FALLBACK&lt;envoy_api_enum_value_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Struct DefaultSubset {
          get { return defaultSubset_; }
          set {
            defaultSubset_ = value;
          }
        }

        /// <summary>Field number for the "subset_selectors" field.</summary>
        public const int SubsetSelectorsFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> _repeated_subsetSelectors_codec
            = pb::FieldCodec.ForMessage(26, global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector.Parser);
        private readonly pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> subsetSelectors_ = new pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector>();
        /// <summary>
        /// For each entry, LbEndpoint.Metadata's
        /// *envoy.lb* namespace is traversed and a subset is created for each unique
        /// combination of key and value. For example:
        ///
        /// .. code-block:: json
        ///
        ///   { "subset_selectors": [
        ///       { "keys": [ "version" ] },
        ///       { "keys": [ "stage", "hardware_type" ] }
        ///   ]}
        ///
        /// A subset is matched when the metadata from the selected route and
        /// weighted cluster contains the same keys and values as the subset's
        /// metadata. The same host may appear in multiple subsets.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetSelector> SubsetSelectors {
          get { return subsetSelectors_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as LbSubsetConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(LbSubsetConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (FallbackPolicy != other.FallbackPolicy) return false;
          if (!object.Equals(DefaultSubset, other.DefaultSubset)) return false;
          if(!subsetSelectors_.Equals(other.subsetSelectors_)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (FallbackPolicy != 0) hash ^= FallbackPolicy.GetHashCode();
          if (defaultSubset_ != null) hash ^= DefaultSubset.GetHashCode();
          hash ^= subsetSelectors_.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (FallbackPolicy != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) FallbackPolicy);
          }
          if (defaultSubset_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(DefaultSubset);
          }
          subsetSelectors_.WriteTo(output, _repeated_subsetSelectors_codec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (FallbackPolicy != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) FallbackPolicy);
          }
          if (defaultSubset_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultSubset);
          }
          size += subsetSelectors_.CalculateSize(_repeated_subsetSelectors_codec);
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(LbSubsetConfig other) {
          if (other == null) {
            return;
          }
          if (other.FallbackPolicy != 0) {
            FallbackPolicy = other.FallbackPolicy;
          }
          if (other.defaultSubset_ != null) {
            if (defaultSubset_ == null) {
              defaultSubset_ = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            DefaultSubset.MergeFrom(other.DefaultSubset);
          }
          subsetSelectors_.Add(other.subsetSelectors_);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                fallbackPolicy_ = (global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Types.LbSubsetFallbackPolicy) input.ReadEnum();
                break;
              }
              case 18: {
                if (defaultSubset_ == null) {
                  defaultSubset_ = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(defaultSubset_);
                break;
              }
              case 26: {
                subsetSelectors_.AddEntriesFrom(input, _repeated_subsetSelectors_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the LbSubsetConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// If NO_FALLBACK is selected, a result
          /// equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
          /// any cluster endpoint may be returned (subject to policy, health checks,
          /// etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
          /// endpoints matching the values from the default_subset field.
          /// </summary>
          public enum LbSubsetFallbackPolicy {
            [pbr::OriginalName("NO_FALLBACK")] NoFallback = 0,
            [pbr::OriginalName("ANY_ENDPOINT")] AnyEndpoint = 1,
            [pbr::OriginalName("DEFAULT_SUBSET")] DefaultSubset = 2,
          }

          /// <summary>
          /// Specifications for subsets.
          /// </summary>
          public sealed partial class LbSubsetSelector : pb::IMessage<LbSubsetSelector> {
            private static readonly pb::MessageParser<LbSubsetSelector> _parser = new pb::MessageParser<LbSubsetSelector>(() => new LbSubsetSelector());
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<LbSubsetSelector> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.LbSubsetConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LbSubsetSelector() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LbSubsetSelector(LbSubsetSelector other) : this() {
              keys_ = other.keys_.Clone();
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public LbSubsetSelector Clone() {
              return new LbSubsetSelector(this);
            }

            /// <summary>Field number for the "keys" field.</summary>
            public const int KeysFieldNumber = 1;
            private static readonly pb::FieldCodec<string> _repeated_keys_codec
                = pb::FieldCodec.ForString(10);
            private readonly pbc::RepeatedField<string> keys_ = new pbc::RepeatedField<string>();
            /// <summary>
            /// List of keys to match with the weighted cluster metadata.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public pbc::RepeatedField<string> Keys {
              get { return keys_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as LbSubsetSelector);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(LbSubsetSelector other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if(!keys_.Equals(other.keys_)) return false;
              return true;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              hash ^= keys_.GetHashCode();
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              keys_.WriteTo(output, _repeated_keys_codec);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              size += keys_.CalculateSize(_repeated_keys_codec);
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(LbSubsetSelector other) {
              if (other == null) {
                return;
              }
              keys_.Add(other.keys_);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 10: {
                    keys_.AddEntriesFrom(input, _repeated_keys_codec);
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

      /// <summary>
      /// Specific configuration for the :ref:`RingHash&lt;arch_overview_load_balancing_types_ring_hash>`
      /// load balancing policy.
      /// </summary>
      public sealed partial class RingHashLbConfig : pb::IMessage<RingHashLbConfig> {
        private static readonly pb::MessageParser<RingHashLbConfig> _parser = new pb::MessageParser<RingHashLbConfig>(() => new RingHashLbConfig());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<RingHashLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RingHashLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RingHashLbConfig(RingHashLbConfig other) : this() {
          MinimumRingSize = other.MinimumRingSize;
          DeprecatedV1 = other.deprecatedV1_ != null ? other.DeprecatedV1.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public RingHashLbConfig Clone() {
          return new RingHashLbConfig(this);
        }

        /// <summary>Field number for the "minimum_ring_size" field.</summary>
        public const int MinimumRingSizeFieldNumber = 1;
        private static readonly pb::FieldCodec<ulong?> _single_minimumRingSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(10);
        private ulong? minimumRingSize_;
        /// <summary>
        /// Minimum hash ring size, i.e. total virtual nodes. A larger size
        /// will provide better request distribution since each host in the
        /// cluster will have more virtual nodes. Defaults to 1024. In the case
        /// that total number of hosts is greater than the minimum, each host will
        /// be allocated a single virtual node.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ulong? MinimumRingSize {
          get { return minimumRingSize_; }
          set {
            minimumRingSize_ = value;
          }
        }

        /// <summary>Field number for the "deprecated_v1" field.</summary>
        public const int DeprecatedV1FieldNumber = 2;
        private global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.DeprecatedV1 deprecatedV1_;
        /// <summary>
        /// Deprecated settings from v1 config.
        /// [#not-implemented-hide:] Hide from docs.
        /// </summary>
        [global::System.ObsoleteAttribute]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.DeprecatedV1 DeprecatedV1 {
          get { return deprecatedV1_; }
          set {
            deprecatedV1_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as RingHashLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(RingHashLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MinimumRingSize != other.MinimumRingSize) return false;
          if (!object.Equals(DeprecatedV1, other.DeprecatedV1)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (minimumRingSize_ != null) hash ^= MinimumRingSize.GetHashCode();
          if (deprecatedV1_ != null) hash ^= DeprecatedV1.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (minimumRingSize_ != null) {
            _single_minimumRingSize_codec.WriteTagAndValue(output, MinimumRingSize);
          }
          if (deprecatedV1_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(DeprecatedV1);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (minimumRingSize_ != null) {
            size += _single_minimumRingSize_codec.CalculateSizeWithTag(MinimumRingSize);
          }
          if (deprecatedV1_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(DeprecatedV1);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(RingHashLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.minimumRingSize_ != null) {
            if (minimumRingSize_ == null || other.MinimumRingSize != 0UL) {
              MinimumRingSize = other.MinimumRingSize;
            }
          }
          if (other.deprecatedV1_ != null) {
            if (deprecatedV1_ == null) {
              deprecatedV1_ = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.DeprecatedV1();
            }
            DeprecatedV1.MergeFrom(other.DeprecatedV1);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                ulong? value = _single_minimumRingSize_codec.Read(input);
                if (minimumRingSize_ == null || value != 0UL) {
                  MinimumRingSize = value;
                }
                break;
              }
              case 18: {
                if (deprecatedV1_ == null) {
                  deprecatedV1_ = new global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Types.DeprecatedV1();
                }
                input.ReadMessage(deprecatedV1_);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the RingHashLbConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          /// <summary>
          /// [#not-implemented-hide:] Hide from docs.
          /// </summary>
          public sealed partial class DeprecatedV1 : pb::IMessage<DeprecatedV1> {
            private static readonly pb::MessageParser<DeprecatedV1> _parser = new pb::MessageParser<DeprecatedV1>(() => new DeprecatedV1());
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<DeprecatedV1> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.RingHashLbConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DeprecatedV1() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DeprecatedV1(DeprecatedV1 other) : this() {
              UseStdHash = other.UseStdHash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public DeprecatedV1 Clone() {
              return new DeprecatedV1(this);
            }

            /// <summary>Field number for the "use_std_hash" field.</summary>
            public const int UseStdHashFieldNumber = 1;
            private static readonly pb::FieldCodec<bool?> _single_useStdHash_codec = pb::FieldCodec.ForStructWrapper<bool>(10);
            private bool? useStdHash_;
            /// <summary>
            /// Defaults to true, meaning that std::hash is used to hash hosts onto
            /// the ketama ring. std::hash can vary by platform. For this reason,
            /// Envoy will eventually use `xxHash &lt;https://github.com/Cyan4973/xxHash>`_
            /// by default. This field exists for
            /// migration purposes and will eventually be deprecated. Set it to false
            /// to use `xxHash &lt;https://github.com/Cyan4973/xxHash>`_ now.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool? UseStdHash {
              get { return useStdHash_; }
              set {
                useStdHash_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as DeprecatedV1);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(DeprecatedV1 other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (UseStdHash != other.UseStdHash) return false;
              return true;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (useStdHash_ != null) hash ^= UseStdHash.GetHashCode();
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (useStdHash_ != null) {
                _single_useStdHash_codec.WriteTagAndValue(output, UseStdHash);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (useStdHash_ != null) {
                size += _single_useStdHash_codec.CalculateSizeWithTag(UseStdHash);
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(DeprecatedV1 other) {
              if (other == null) {
                return;
              }
              if (other.useStdHash_ != null) {
                if (useStdHash_ == null || other.UseStdHash != false) {
                  UseStdHash = other.UseStdHash;
                }
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 10: {
                    bool? value = _single_useStdHash_codec.Read(input);
                    if (useStdHash_ == null || value != false) {
                      UseStdHash = value;
                    }
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

      /// <summary>
      /// Common configuration for all load balancer implementations.
      /// </summary>
      public sealed partial class CommonLbConfig : pb::IMessage<CommonLbConfig> {
        private static readonly pb::MessageParser<CommonLbConfig> _parser = new pb::MessageParser<CommonLbConfig>(() => new CommonLbConfig());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<CommonLbConfig> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Api.V2.Cluster.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CommonLbConfig() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CommonLbConfig(CommonLbConfig other) : this() {
          HealthyPanicThreshold = other.healthyPanicThreshold_ != null ? other.HealthyPanicThreshold.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public CommonLbConfig Clone() {
          return new CommonLbConfig(this);
        }

        /// <summary>Field number for the "healthy_panic_threshold" field.</summary>
        public const int HealthyPanicThresholdFieldNumber = 1;
        private global::Envoy.Api.V2.Core.Percent healthyPanicThreshold_;
        /// <summary>
        /// Configures the :ref:`healthy panic threshold &lt;arch_overview_load_balancing_panic_threshold>`.
        /// If not specified, the default is 50%.
        ///
        /// .. note::
        ///   The specified percent will be truncated to the nearest 1%.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Envoy.Api.V2.Core.Percent HealthyPanicThreshold {
          get { return healthyPanicThreshold_; }
          set {
            healthyPanicThreshold_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as CommonLbConfig);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(CommonLbConfig other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(HealthyPanicThreshold, other.HealthyPanicThreshold)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (healthyPanicThreshold_ != null) hash ^= HealthyPanicThreshold.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (healthyPanicThreshold_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(HealthyPanicThreshold);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (healthyPanicThreshold_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(HealthyPanicThreshold);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(CommonLbConfig other) {
          if (other == null) {
            return;
          }
          if (other.healthyPanicThreshold_ != null) {
            if (healthyPanicThreshold_ == null) {
              healthyPanicThreshold_ = new global::Envoy.Api.V2.Core.Percent();
            }
            HealthyPanicThreshold.MergeFrom(other.HealthyPanicThreshold);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                if (healthyPanicThreshold_ == null) {
                  healthyPanicThreshold_ = new global::Envoy.Api.V2.Core.Percent();
                }
                input.ReadMessage(healthyPanicThreshold_);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the CommonLbConfig message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public sealed partial class ZoneAwareLbConfig : pb::IMessage<ZoneAwareLbConfig> {
            private static readonly pb::MessageParser<ZoneAwareLbConfig> _parser = new pb::MessageParser<ZoneAwareLbConfig>(() => new ZoneAwareLbConfig());
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<ZoneAwareLbConfig> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::Envoy.Api.V2.Cluster.Types.CommonLbConfig.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ZoneAwareLbConfig() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ZoneAwareLbConfig(ZoneAwareLbConfig other) : this() {
              RoutingEnabled = other.routingEnabled_ != null ? other.RoutingEnabled.Clone() : null;
              MinClusterSize = other.MinClusterSize;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ZoneAwareLbConfig Clone() {
              return new ZoneAwareLbConfig(this);
            }

            /// <summary>Field number for the "routing_enabled" field.</summary>
            public const int RoutingEnabledFieldNumber = 1;
            private global::Envoy.Api.V2.Core.Percent routingEnabled_;
            /// <summary>
            /// [#not-implemented-hide:]
            /// Configures percentage of requests that will be considered for zone aware routing
            /// if zone aware routing is configured. If not specified, the default is 100%.
            /// * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing>`.
            /// * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing>`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public global::Envoy.Api.V2.Core.Percent RoutingEnabled {
              get { return routingEnabled_; }
              set {
                routingEnabled_ = value;
              }
            }

            /// <summary>Field number for the "min_cluster_size" field.</summary>
            public const int MinClusterSizeFieldNumber = 2;
            private static readonly pb::FieldCodec<ulong?> _single_minClusterSize_codec = pb::FieldCodec.ForStructWrapper<ulong>(18);
            private ulong? minClusterSize_;
            /// <summary>
            /// [#not-implemented-hide:]
            /// Configures minimum upstream cluster size required for zone aware routing
            /// If upstream cluster size is less than specified, zone aware routing is not performed
            /// even if zone aware routing is configured. If not specified, the default is 6.
            /// * :ref:`runtime values &lt;config_cluster_manager_cluster_runtime_zone_routing>`.
            /// * :ref:`Zone aware routing support &lt;arch_overview_load_balancing_zone_aware_routing>`.
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ulong? MinClusterSize {
              get { return minClusterSize_; }
              set {
                minClusterSize_ = value;
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as ZoneAwareLbConfig);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(ZoneAwareLbConfig other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (!object.Equals(RoutingEnabled, other.RoutingEnabled)) return false;
              if (MinClusterSize != other.MinClusterSize) return false;
              return true;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (routingEnabled_ != null) hash ^= RoutingEnabled.GetHashCode();
              if (minClusterSize_ != null) hash ^= MinClusterSize.GetHashCode();
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (routingEnabled_ != null) {
                output.WriteRawTag(10);
                output.WriteMessage(RoutingEnabled);
              }
              if (minClusterSize_ != null) {
                _single_minClusterSize_codec.WriteTagAndValue(output, MinClusterSize);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (routingEnabled_ != null) {
                size += 1 + pb::CodedOutputStream.ComputeMessageSize(RoutingEnabled);
              }
              if (minClusterSize_ != null) {
                size += _single_minClusterSize_codec.CalculateSizeWithTag(MinClusterSize);
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(ZoneAwareLbConfig other) {
              if (other == null) {
                return;
              }
              if (other.routingEnabled_ != null) {
                if (routingEnabled_ == null) {
                  routingEnabled_ = new global::Envoy.Api.V2.Core.Percent();
                }
                RoutingEnabled.MergeFrom(other.RoutingEnabled);
              }
              if (other.minClusterSize_ != null) {
                if (minClusterSize_ == null || other.MinClusterSize != 0UL) {
                  MinClusterSize = other.MinClusterSize;
                }
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 10: {
                    if (routingEnabled_ == null) {
                      routingEnabled_ = new global::Envoy.Api.V2.Core.Percent();
                    }
                    input.ReadMessage(routingEnabled_);
                    break;
                  }
                  case 18: {
                    ulong? value = _single_minClusterSize_codec.Read(input);
                    if (minClusterSize_ == null || value != 0UL) {
                      MinClusterSize = value;
                    }
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

    }
    #endregion

  }

  /// <summary>
  /// An extensible structure containing the address Envoy should bind to when
  /// establishing upstream connections.
  /// </summary>
  public sealed partial class UpstreamBindConfig : pb::IMessage<UpstreamBindConfig> {
    private static readonly pb::MessageParser<UpstreamBindConfig> _parser = new pb::MessageParser<UpstreamBindConfig>(() => new UpstreamBindConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpstreamBindConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.CdsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamBindConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamBindConfig(UpstreamBindConfig other) : this() {
      SourceAddress = other.sourceAddress_ != null ? other.SourceAddress.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpstreamBindConfig Clone() {
      return new UpstreamBindConfig(this);
    }

    /// <summary>Field number for the "source_address" field.</summary>
    public const int SourceAddressFieldNumber = 1;
    private global::Envoy.Api.V2.Core.Address sourceAddress_;
    /// <summary>
    /// The address Envoy should bind to when establishing upstream connections.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Address SourceAddress {
      get { return sourceAddress_; }
      set {
        sourceAddress_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpstreamBindConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpstreamBindConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SourceAddress, other.SourceAddress)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (sourceAddress_ != null) hash ^= SourceAddress.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (sourceAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SourceAddress);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (sourceAddress_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceAddress);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpstreamBindConfig other) {
      if (other == null) {
        return;
      }
      if (other.sourceAddress_ != null) {
        if (sourceAddress_ == null) {
          sourceAddress_ = new global::Envoy.Api.V2.Core.Address();
        }
        SourceAddress.MergeFrom(other.SourceAddress);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (sourceAddress_ == null) {
              sourceAddress_ = new global::Envoy.Api.V2.Core.Address();
            }
            input.ReadMessage(sourceAddress_);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
