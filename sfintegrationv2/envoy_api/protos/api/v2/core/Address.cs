// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: address.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Api.V2.Core {

  /// <summary>Holder for reflection information generated from address.proto</summary>
  public static partial class AddressReflection {

    #region Descriptor
    /// <summary>File descriptor for address.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static AddressReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg1hZGRyZXNzLnByb3RvEhFlbnZveS5hcGkudjIuY29yZRoeZ29vZ2xlL3By",
            "b3RvYnVmL3dyYXBwZXJzLnByb3RvGhd2YWxpZGF0ZS92YWxpZGF0ZS5wcm90",
            "bxoUZ29nb3Byb3RvL2dvZ28ucHJvdG8iHwoEUGlwZRIXCgRwYXRoGAEgASgJ",
            "Qgm66cADBHICIAEiiQIKDVNvY2tldEFkZHJlc3MSRwoIcHJvdG9jb2wYASAB",
            "KA4yKS5lbnZveS5hcGkudjIuY29yZS5Tb2NrZXRBZGRyZXNzLlByb3RvY29s",
            "Qgq66cADBYIBAhABEhoKB2FkZHJlc3MYAiABKAlCCbrpwAMEcgIgARIUCgpw",
            "b3J0X3ZhbHVlGAMgASgNSAASFAoKbmFtZWRfcG9ydBgEIAEoCUgAEhUKDXJl",
            "c29sdmVyX25hbWUYBSABKAkSEwoLaXB2NF9jb21wYXQYBiABKAgiIgoIUHJv",
            "dG9jb2wSBwoDVENQEAASBwoDVURQEAEaBIijHgBCFwoOcG9ydF9zcGVjaWZp",
            "ZXISBbjpwAMBIlYKCkJpbmRDb25maWcSSAoOc291cmNlX2FkZHJlc3MYASAB",
            "KAsyIC5lbnZveS5hcGkudjIuY29yZS5Tb2NrZXRBZGRyZXNzQg666cADBYoB",
            "AhAByN4fACKAAQoHQWRkcmVzcxI6Cg5zb2NrZXRfYWRkcmVzcxgBIAEoCzIg",
            "LmVudm95LmFwaS52Mi5jb3JlLlNvY2tldEFkZHJlc3NIABInCgRwaXBlGAIg",
            "ASgLMhcuZW52b3kuYXBpLnYyLmNvcmUuUGlwZUgAQhAKB2FkZHJlc3MSBbjp",
            "wAMBImwKCUNpZHJSYW5nZRIhCg5hZGRyZXNzX3ByZWZpeBgBIAEoCUIJuunA",
            "AwRyAiABEjwKCnByZWZpeF9sZW4YAiABKAsyHC5nb29nbGUucHJvdG9idWYu",
            "VUludDMyVmFsdWVCCrrpwAMFKgMYgAFCBKjiHgFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, global::Gogoproto.GogoReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.Pipe), global::Envoy.Api.V2.Core.Pipe.Parser, new[]{ "Path" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.SocketAddress), global::Envoy.Api.V2.Core.SocketAddress.Parser, new[]{ "Protocol", "Address", "PortValue", "NamedPort", "ResolverName", "Ipv4Compat" }, new[]{ "PortSpecifier" }, new[]{ typeof(global::Envoy.Api.V2.Core.SocketAddress.Types.Protocol) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.BindConfig), global::Envoy.Api.V2.Core.BindConfig.Parser, new[]{ "SourceAddress" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.Address), global::Envoy.Api.V2.Core.Address.Parser, new[]{ "SocketAddress", "Pipe" }, new[]{ "Address" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Api.V2.Core.CidrRange), global::Envoy.Api.V2.Core.CidrRange.Parser, new[]{ "AddressPrefix", "PrefixLen" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class Pipe : pb::IMessage<Pipe> {
    private static readonly pb::MessageParser<Pipe> _parser = new pb::MessageParser<Pipe>(() => new Pipe());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Pipe> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.AddressReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Pipe() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Pipe(Pipe other) : this() {
      path_ = other.path_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Pipe Clone() {
      return new Pipe(this);
    }

    /// <summary>Field number for the "path" field.</summary>
    public const int PathFieldNumber = 1;
    private string path_ = "";
    /// <summary>
    /// Unix Domain Socket path. On Linux, paths starting with '@' will use the
    /// abstract namespace. The starting '@' is replaced by a null byte by Envoy.
    /// Paths starting with '@' will result in an error in environments other than
    /// Linux.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Path {
      get { return path_; }
      set {
        path_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Pipe);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Pipe other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Path != other.Path) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Path.Length != 0) hash ^= Path.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Path.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Path);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Path.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Path);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Pipe other) {
      if (other == null) {
        return;
      }
      if (other.Path.Length != 0) {
        Path = other.Path;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Path = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class SocketAddress : pb::IMessage<SocketAddress> {
    private static readonly pb::MessageParser<SocketAddress> _parser = new pb::MessageParser<SocketAddress>(() => new SocketAddress());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SocketAddress> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.AddressReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SocketAddress() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SocketAddress(SocketAddress other) : this() {
      protocol_ = other.protocol_;
      address_ = other.address_;
      resolverName_ = other.resolverName_;
      ipv4Compat_ = other.ipv4Compat_;
      switch (other.PortSpecifierCase) {
        case PortSpecifierOneofCase.PortValue:
          PortValue = other.PortValue;
          break;
        case PortSpecifierOneofCase.NamedPort:
          NamedPort = other.NamedPort;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SocketAddress Clone() {
      return new SocketAddress(this);
    }

    /// <summary>Field number for the "protocol" field.</summary>
    public const int ProtocolFieldNumber = 1;
    private global::Envoy.Api.V2.Core.SocketAddress.Types.Protocol protocol_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.SocketAddress.Types.Protocol Protocol {
      get { return protocol_; }
      set {
        protocol_ = value;
      }
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 2;
    private string address_ = "";
    /// <summary>
    /// The address for this socket. :ref:`Listeners &lt;config_listeners>` will bind
    /// to the address or outbound connections will be made. An empty address is
    /// not allowed, specify ``0.0.0.0`` or ``::`` to bind any. It's still possible to
    /// distinguish on an address via the prefix/suffix matching in
    /// FilterChainMatch after connection. For :ref:`clusters
    /// &lt;config_cluster_manager_cluster>`, an address may be either an IP or
    /// hostname to be resolved via DNS. If it is a hostname, :ref:`resolver_name
    /// &lt;envoy_api_field_core.SocketAddress.resolver_name>` should be set unless default
    /// (i.e. DNS) resolution is expected.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Address {
      get { return address_; }
      set {
        address_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "port_value" field.</summary>
    public const int PortValueFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint PortValue {
      get { return portSpecifierCase_ == PortSpecifierOneofCase.PortValue ? (uint) portSpecifier_ : 0; }
      set {
        portSpecifier_ = value;
        portSpecifierCase_ = PortSpecifierOneofCase.PortValue;
      }
    }

    /// <summary>Field number for the "named_port" field.</summary>
    public const int NamedPortFieldNumber = 4;
    /// <summary>
    /// This is only valid if :ref:`resolver_name
    /// &lt;envoy_api_field_core.SocketAddress.resolver_name>` is specified below and the
    /// named resolver is capable of named port resolution.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NamedPort {
      get { return portSpecifierCase_ == PortSpecifierOneofCase.NamedPort ? (string) portSpecifier_ : ""; }
      set {
        portSpecifier_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
        portSpecifierCase_ = PortSpecifierOneofCase.NamedPort;
      }
    }

    /// <summary>Field number for the "resolver_name" field.</summary>
    public const int ResolverNameFieldNumber = 5;
    private string resolverName_ = "";
    /// <summary>
    /// The name of the resolver. This must have been registered with Envoy. If this is
    /// empty, a context dependent default applies. If address is a hostname this
    /// should be set for resolution other than DNS. If the address is a concrete
    /// IP address, no resolution will occur.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ResolverName {
      get { return resolverName_; }
      set {
        resolverName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "ipv4_compat" field.</summary>
    public const int Ipv4CompatFieldNumber = 6;
    private bool ipv4Compat_;
    /// <summary>
    /// When binding to an IPv6 address above, this enables `IPv4 compatibity
    /// &lt;https://tools.ietf.org/html/rfc3493#page-11>`_. Binding to ``::`` will
    /// allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into
    /// IPv6 space as ``::FFFF:&lt;IPv4-address>``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Ipv4Compat {
      get { return ipv4Compat_; }
      set {
        ipv4Compat_ = value;
      }
    }

    private object portSpecifier_;
    /// <summary>Enum of possible cases for the "port_specifier" oneof.</summary>
    public enum PortSpecifierOneofCase {
      None = 0,
      PortValue = 3,
      NamedPort = 4,
    }
    private PortSpecifierOneofCase portSpecifierCase_ = PortSpecifierOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PortSpecifierOneofCase PortSpecifierCase {
      get { return portSpecifierCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPortSpecifier() {
      portSpecifierCase_ = PortSpecifierOneofCase.None;
      portSpecifier_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SocketAddress);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SocketAddress other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Protocol != other.Protocol) return false;
      if (Address != other.Address) return false;
      if (PortValue != other.PortValue) return false;
      if (NamedPort != other.NamedPort) return false;
      if (ResolverName != other.ResolverName) return false;
      if (Ipv4Compat != other.Ipv4Compat) return false;
      if (PortSpecifierCase != other.PortSpecifierCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Protocol != 0) hash ^= Protocol.GetHashCode();
      if (Address.Length != 0) hash ^= Address.GetHashCode();
      if (portSpecifierCase_ == PortSpecifierOneofCase.PortValue) hash ^= PortValue.GetHashCode();
      if (portSpecifierCase_ == PortSpecifierOneofCase.NamedPort) hash ^= NamedPort.GetHashCode();
      if (ResolverName.Length != 0) hash ^= ResolverName.GetHashCode();
      if (Ipv4Compat != false) hash ^= Ipv4Compat.GetHashCode();
      hash ^= (int) portSpecifierCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Protocol != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Protocol);
      }
      if (Address.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Address);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.PortValue) {
        output.WriteRawTag(24);
        output.WriteUInt32(PortValue);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.NamedPort) {
        output.WriteRawTag(34);
        output.WriteString(NamedPort);
      }
      if (ResolverName.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(ResolverName);
      }
      if (Ipv4Compat != false) {
        output.WriteRawTag(48);
        output.WriteBool(Ipv4Compat);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Protocol != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Protocol);
      }
      if (Address.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Address);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.PortValue) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PortValue);
      }
      if (portSpecifierCase_ == PortSpecifierOneofCase.NamedPort) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NamedPort);
      }
      if (ResolverName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ResolverName);
      }
      if (Ipv4Compat != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SocketAddress other) {
      if (other == null) {
        return;
      }
      if (other.Protocol != 0) {
        Protocol = other.Protocol;
      }
      if (other.Address.Length != 0) {
        Address = other.Address;
      }
      if (other.ResolverName.Length != 0) {
        ResolverName = other.ResolverName;
      }
      if (other.Ipv4Compat != false) {
        Ipv4Compat = other.Ipv4Compat;
      }
      switch (other.PortSpecifierCase) {
        case PortSpecifierOneofCase.PortValue:
          PortValue = other.PortValue;
          break;
        case PortSpecifierOneofCase.NamedPort:
          NamedPort = other.NamedPort;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            protocol_ = (global::Envoy.Api.V2.Core.SocketAddress.Types.Protocol) input.ReadEnum();
            break;
          }
          case 18: {
            Address = input.ReadString();
            break;
          }
          case 24: {
            PortValue = input.ReadUInt32();
            break;
          }
          case 34: {
            NamedPort = input.ReadString();
            break;
          }
          case 42: {
            ResolverName = input.ReadString();
            break;
          }
          case 48: {
            Ipv4Compat = input.ReadBool();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the SocketAddress message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Protocol {
        [pbr::OriginalName("TCP")] Tcp = 0,
        /// <summary>
        /// [#not-implemented-hide:]
        /// </summary>
        [pbr::OriginalName("UDP")] Udp = 1,
      }

    }
    #endregion

  }

  public sealed partial class BindConfig : pb::IMessage<BindConfig> {
    private static readonly pb::MessageParser<BindConfig> _parser = new pb::MessageParser<BindConfig>(() => new BindConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BindConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.AddressReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BindConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BindConfig(BindConfig other) : this() {
      SourceAddress = other.sourceAddress_ != null ? other.SourceAddress.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BindConfig Clone() {
      return new BindConfig(this);
    }

    /// <summary>Field number for the "source_address" field.</summary>
    public const int SourceAddressFieldNumber = 1;
    private global::Envoy.Api.V2.Core.SocketAddress sourceAddress_;
    /// <summary>
    /// The address to bind to when creating a socket.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.SocketAddress SourceAddress {
      get { return sourceAddress_; }
      set {
        sourceAddress_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BindConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BindConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SourceAddress, other.SourceAddress)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (sourceAddress_ != null) hash ^= SourceAddress.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (sourceAddress_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(SourceAddress);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (sourceAddress_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SourceAddress);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BindConfig other) {
      if (other == null) {
        return;
      }
      if (other.sourceAddress_ != null) {
        if (sourceAddress_ == null) {
          sourceAddress_ = new global::Envoy.Api.V2.Core.SocketAddress();
        }
        SourceAddress.MergeFrom(other.SourceAddress);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (sourceAddress_ == null) {
              sourceAddress_ = new global::Envoy.Api.V2.Core.SocketAddress();
            }
            input.ReadMessage(sourceAddress_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Addresses specify either a logical or physical address and port, which are
  /// used to tell Envoy where to bind/listen, connect to upstream and find
  /// management servers.
  /// </summary>
  public sealed partial class Address : pb::IMessage<Address> {
    private static readonly pb::MessageParser<Address> _parser = new pb::MessageParser<Address>(() => new Address());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Address> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.AddressReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Address() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Address(Address other) : this() {
      switch (other.AddressCase) {
        case AddressOneofCase.SocketAddress:
          SocketAddress = other.SocketAddress.Clone();
          break;
        case AddressOneofCase.Pipe:
          Pipe = other.Pipe.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Address Clone() {
      return new Address(this);
    }

    /// <summary>Field number for the "socket_address" field.</summary>
    public const int SocketAddressFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.SocketAddress SocketAddress {
      get { return addressCase_ == AddressOneofCase.SocketAddress ? (global::Envoy.Api.V2.Core.SocketAddress) address_ : null; }
      set {
        address_ = value;
        addressCase_ = value == null ? AddressOneofCase.None : AddressOneofCase.SocketAddress;
      }
    }

    /// <summary>Field number for the "pipe" field.</summary>
    public const int PipeFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.Pipe Pipe {
      get { return addressCase_ == AddressOneofCase.Pipe ? (global::Envoy.Api.V2.Core.Pipe) address_ : null; }
      set {
        address_ = value;
        addressCase_ = value == null ? AddressOneofCase.None : AddressOneofCase.Pipe;
      }
    }

    private object address_;
    /// <summary>Enum of possible cases for the "address" oneof.</summary>
    public enum AddressOneofCase {
      None = 0,
      SocketAddress = 1,
      Pipe = 2,
    }
    private AddressOneofCase addressCase_ = AddressOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AddressOneofCase AddressCase {
      get { return addressCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearAddress() {
      addressCase_ = AddressOneofCase.None;
      address_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Address);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Address other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(SocketAddress, other.SocketAddress)) return false;
      if (!object.Equals(Pipe, other.Pipe)) return false;
      if (AddressCase != other.AddressCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (addressCase_ == AddressOneofCase.SocketAddress) hash ^= SocketAddress.GetHashCode();
      if (addressCase_ == AddressOneofCase.Pipe) hash ^= Pipe.GetHashCode();
      hash ^= (int) addressCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (addressCase_ == AddressOneofCase.SocketAddress) {
        output.WriteRawTag(10);
        output.WriteMessage(SocketAddress);
      }
      if (addressCase_ == AddressOneofCase.Pipe) {
        output.WriteRawTag(18);
        output.WriteMessage(Pipe);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (addressCase_ == AddressOneofCase.SocketAddress) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SocketAddress);
      }
      if (addressCase_ == AddressOneofCase.Pipe) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Pipe);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Address other) {
      if (other == null) {
        return;
      }
      switch (other.AddressCase) {
        case AddressOneofCase.SocketAddress:
          if (SocketAddress == null) {
            SocketAddress = new global::Envoy.Api.V2.Core.SocketAddress();
          }
          SocketAddress.MergeFrom(other.SocketAddress);
          break;
        case AddressOneofCase.Pipe:
          if (Pipe == null) {
            Pipe = new global::Envoy.Api.V2.Core.Pipe();
          }
          Pipe.MergeFrom(other.Pipe);
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            global::Envoy.Api.V2.Core.SocketAddress subBuilder = new global::Envoy.Api.V2.Core.SocketAddress();
            if (addressCase_ == AddressOneofCase.SocketAddress) {
              subBuilder.MergeFrom(SocketAddress);
            }
            input.ReadMessage(subBuilder);
            SocketAddress = subBuilder;
            break;
          }
          case 18: {
            global::Envoy.Api.V2.Core.Pipe subBuilder = new global::Envoy.Api.V2.Core.Pipe();
            if (addressCase_ == AddressOneofCase.Pipe) {
              subBuilder.MergeFrom(Pipe);
            }
            input.ReadMessage(subBuilder);
            Pipe = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// CidrRange specifies an IP Address and a prefix length to construct
  /// the subnet mask for a `CIDR &lt;https://tools.ietf.org/html/rfc4632>`_ range.
  /// </summary>
  public sealed partial class CidrRange : pb::IMessage<CidrRange> {
    private static readonly pb::MessageParser<CidrRange> _parser = new pb::MessageParser<CidrRange>(() => new CidrRange());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CidrRange> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Api.V2.Core.AddressReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CidrRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CidrRange(CidrRange other) : this() {
      addressPrefix_ = other.addressPrefix_;
      PrefixLen = other.PrefixLen;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CidrRange Clone() {
      return new CidrRange(this);
    }

    /// <summary>Field number for the "address_prefix" field.</summary>
    public const int AddressPrefixFieldNumber = 1;
    private string addressPrefix_ = "";
    /// <summary>
    /// IPv4 or IPv6 address, e.g. ``192.0.0.0`` or ``2001:db8::``.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AddressPrefix {
      get { return addressPrefix_; }
      set {
        addressPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "prefix_len" field.</summary>
    public const int PrefixLenFieldNumber = 2;
    private static readonly pb::FieldCodec<uint?> _single_prefixLen_codec = pb::FieldCodec.ForStructWrapper<uint>(18);
    private uint? prefixLen_;
    /// <summary>
    /// Length of prefix, e.g. 0, 32.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint? PrefixLen {
      get { return prefixLen_; }
      set {
        prefixLen_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CidrRange);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CidrRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AddressPrefix != other.AddressPrefix) return false;
      if (PrefixLen != other.PrefixLen) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AddressPrefix.Length != 0) hash ^= AddressPrefix.GetHashCode();
      if (prefixLen_ != null) hash ^= PrefixLen.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AddressPrefix.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(AddressPrefix);
      }
      if (prefixLen_ != null) {
        _single_prefixLen_codec.WriteTagAndValue(output, PrefixLen);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AddressPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AddressPrefix);
      }
      if (prefixLen_ != null) {
        size += _single_prefixLen_codec.CalculateSizeWithTag(PrefixLen);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CidrRange other) {
      if (other == null) {
        return;
      }
      if (other.AddressPrefix.Length != 0) {
        AddressPrefix = other.AddressPrefix;
      }
      if (other.prefixLen_ != null) {
        if (prefixLen_ == null || other.PrefixLen != 0) {
          PrefixLen = other.PrefixLen;
        }
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            AddressPrefix = input.ReadString();
            break;
          }
          case 18: {
            uint? value = _single_prefixLen_codec.Read(input);
            if (prefixLen_ == null || value != 0) {
              PrefixLen = value;
            }
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
