// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: v2/trace.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Envoy.Config.Trace.V2 {

  /// <summary>Holder for reflection information generated from v2/trace.proto</summary>
  public static partial class TraceReflection {

    #region Descriptor
    /// <summary>File descriptor for v2/trace.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TraceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg52Mi90cmFjZS5wcm90bxIVZW52b3kuY29uZmlnLnRyYWNlLnYyGiRlbnZv",
            "eS9hcGkvdjIvY29yZS9ncnBjX3NlcnZpY2UucHJvdG8aHGdvb2dsZS9wcm90",
            "b2J1Zi9zdHJ1Y3QucHJvdG8aF3ZhbGlkYXRlL3ZhbGlkYXRlLnByb3RvIoYB",
            "CgdUcmFjaW5nEjEKBGh0dHAYASABKAsyIy5lbnZveS5jb25maWcudHJhY2Uu",
            "djIuVHJhY2luZy5IdHRwGkgKBEh0dHASFwoEbmFtZRgBIAEoCUIJuunAAwRy",
            "AiABEicKBmNvbmZpZxgCIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3Qi",
            "XQoPTGlnaHRzdGVwQ29uZmlnEiQKEWNvbGxlY3Rvcl9jbHVzdGVyGAEgASgJ",
            "Qgm66cADBHICIAESJAoRYWNjZXNzX3Rva2VuX2ZpbGUYAiABKAlCCbrpwAME",
            "cgIgASJbCgxaaXBraW5Db25maWcSJAoRY29sbGVjdG9yX2NsdXN0ZXIYASAB",
            "KAlCCbrpwAMEcgIgARIlChJjb2xsZWN0b3JfZW5kcG9pbnQYAiABKAlCCbrp",
            "wAMEcgIgASJWCg9EeW5hbWljT3RDb25maWcSGgoHbGlicmFyeRgBIAEoCUIJ",
            "uunAAwRyAiABEicKBmNvbmZpZxgCIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5T",
            "dHJ1Y3QiVgoSVHJhY2VTZXJ2aWNlQ29uZmlnEkAKDGdycGNfc2VydmljZRgB",
            "IAEoCzIeLmVudm95LmFwaS52Mi5jb3JlLkdycGNTZXJ2aWNlQgq66cADBYoB",
            "AhABQgRaAnYyYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Envoy.Api.V2.Core.GrpcServiceReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.StructReflection.Descriptor, global::Validate.ValidateReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.Tracing), global::Envoy.Config.Trace.V2.Tracing.Parser, new[]{ "Http" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.Tracing.Types.Http), global::Envoy.Config.Trace.V2.Tracing.Types.Http.Parser, new[]{ "Name", "Config" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.LightstepConfig), global::Envoy.Config.Trace.V2.LightstepConfig.Parser, new[]{ "CollectorCluster", "AccessTokenFile" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.ZipkinConfig), global::Envoy.Config.Trace.V2.ZipkinConfig.Parser, new[]{ "CollectorCluster", "CollectorEndpoint" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.DynamicOtConfig), global::Envoy.Config.Trace.V2.DynamicOtConfig.Parser, new[]{ "Library", "Config" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Envoy.Config.Trace.V2.TraceServiceConfig), global::Envoy.Config.Trace.V2.TraceServiceConfig.Parser, new[]{ "GrpcService" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// The tracing configuration specifies global
  /// settings for the HTTP tracer used by Envoy. The configuration is defined by
  /// the :ref:`Bootstrap &lt;envoy_api_msg_config.bootstrap.v2.Bootstrap>` :ref:`tracing
  /// &lt;envoy_api_field_config.bootstrap.v2.Bootstrap.tracing>` field. Envoy may support other tracers
  /// in the future, but right now the HTTP tracer is the only one supported.
  /// </summary>
  public sealed partial class Tracing : pb::IMessage<Tracing> {
    private static readonly pb::MessageParser<Tracing> _parser = new pb::MessageParser<Tracing>(() => new Tracing());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Tracing> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Trace.V2.TraceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tracing() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tracing(Tracing other) : this() {
      Http = other.http_ != null ? other.Http.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tracing Clone() {
      return new Tracing(this);
    }

    /// <summary>Field number for the "http" field.</summary>
    public const int HttpFieldNumber = 1;
    private global::Envoy.Config.Trace.V2.Tracing.Types.Http http_;
    /// <summary>
    /// Provides configuration for the HTTP tracer.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Config.Trace.V2.Tracing.Types.Http Http {
      get { return http_; }
      set {
        http_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Tracing);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Tracing other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Http, other.Http)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (http_ != null) hash ^= Http.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (http_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Http);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (http_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Http);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Tracing other) {
      if (other == null) {
        return;
      }
      if (other.http_ != null) {
        if (http_ == null) {
          http_ = new global::Envoy.Config.Trace.V2.Tracing.Types.Http();
        }
        Http.MergeFrom(other.Http);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (http_ == null) {
              http_ = new global::Envoy.Config.Trace.V2.Tracing.Types.Http();
            }
            input.ReadMessage(http_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Tracing message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public sealed partial class Http : pb::IMessage<Http> {
        private static readonly pb::MessageParser<Http> _parser = new pb::MessageParser<Http>(() => new Http());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Http> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Envoy.Config.Trace.V2.Tracing.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Http() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Http(Http other) : this() {
          name_ = other.name_;
          Config = other.config_ != null ? other.Config.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Http Clone() {
          return new Http(this);
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 1;
        private string name_ = "";
        /// <summary>
        /// The name of the HTTP trace driver to instantiate. The name must match a
        /// supported HTTP trace driver. *envoy.lightstep*, *envoy.zipkin*, and
        /// *envoy.dynamic.ot* are built-in trace drivers.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "config" field.</summary>
        public const int ConfigFieldNumber = 2;
        private global::Google.Protobuf.WellKnownTypes.Struct config_;
        /// <summary>
        /// Trace driver specific configuration which depends on the driver being
        /// instantiated. See the :ref:`LightstepConfig
        /// &lt;envoy_api_msg_config.trace.v2.LightstepConfig>`, :ref:`ZipkinConfig
        /// &lt;envoy_api_msg_config.trace.v2.ZipkinConfig>`, and :ref:`DynamicOtConfig
        /// &lt;envoy_api_msg_config.trace.v2.DynamicOtConfig>` trace drivers for examples.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Google.Protobuf.WellKnownTypes.Struct Config {
          get { return config_; }
          set {
            config_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Http);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Http other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Name != other.Name) return false;
          if (!object.Equals(Config, other.Config)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          if (config_ != null) hash ^= Config.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Name.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Name);
          }
          if (config_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Config);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          if (config_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Http other) {
          if (other == null) {
            return;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          if (other.config_ != null) {
            if (config_ == null) {
              config_ = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            Config.MergeFrom(other.Config);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                Name = input.ReadString();
                break;
              }
              case 18: {
                if (config_ == null) {
                  config_ = new global::Google.Protobuf.WellKnownTypes.Struct();
                }
                input.ReadMessage(config_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Configuration for the LightStep tracer.
  /// </summary>
  public sealed partial class LightstepConfig : pb::IMessage<LightstepConfig> {
    private static readonly pb::MessageParser<LightstepConfig> _parser = new pb::MessageParser<LightstepConfig>(() => new LightstepConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LightstepConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Trace.V2.TraceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LightstepConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LightstepConfig(LightstepConfig other) : this() {
      collectorCluster_ = other.collectorCluster_;
      accessTokenFile_ = other.accessTokenFile_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LightstepConfig Clone() {
      return new LightstepConfig(this);
    }

    /// <summary>Field number for the "collector_cluster" field.</summary>
    public const int CollectorClusterFieldNumber = 1;
    private string collectorCluster_ = "";
    /// <summary>
    /// The cluster manager cluster that hosts the LightStep collectors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CollectorCluster {
      get { return collectorCluster_; }
      set {
        collectorCluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "access_token_file" field.</summary>
    public const int AccessTokenFileFieldNumber = 2;
    private string accessTokenFile_ = "";
    /// <summary>
    /// File containing the access token to the `LightStep
    /// &lt;http://lightstep.com/>`_ API.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string AccessTokenFile {
      get { return accessTokenFile_; }
      set {
        accessTokenFile_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LightstepConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LightstepConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CollectorCluster != other.CollectorCluster) return false;
      if (AccessTokenFile != other.AccessTokenFile) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CollectorCluster.Length != 0) hash ^= CollectorCluster.GetHashCode();
      if (AccessTokenFile.Length != 0) hash ^= AccessTokenFile.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (CollectorCluster.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CollectorCluster);
      }
      if (AccessTokenFile.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(AccessTokenFile);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CollectorCluster.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CollectorCluster);
      }
      if (AccessTokenFile.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(AccessTokenFile);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LightstepConfig other) {
      if (other == null) {
        return;
      }
      if (other.CollectorCluster.Length != 0) {
        CollectorCluster = other.CollectorCluster;
      }
      if (other.AccessTokenFile.Length != 0) {
        AccessTokenFile = other.AccessTokenFile;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            CollectorCluster = input.ReadString();
            break;
          }
          case 18: {
            AccessTokenFile = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class ZipkinConfig : pb::IMessage<ZipkinConfig> {
    private static readonly pb::MessageParser<ZipkinConfig> _parser = new pb::MessageParser<ZipkinConfig>(() => new ZipkinConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ZipkinConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Trace.V2.TraceReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ZipkinConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ZipkinConfig(ZipkinConfig other) : this() {
      collectorCluster_ = other.collectorCluster_;
      collectorEndpoint_ = other.collectorEndpoint_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ZipkinConfig Clone() {
      return new ZipkinConfig(this);
    }

    /// <summary>Field number for the "collector_cluster" field.</summary>
    public const int CollectorClusterFieldNumber = 1;
    private string collectorCluster_ = "";
    /// <summary>
    /// The cluster manager cluster that hosts the Zipkin collectors. Note that the
    /// Zipkin cluster must be defined in the :ref:`Bootstrap static cluster
    /// resources &lt;envoy_api_field_config.bootstrap.v2.Bootstrap.StaticResources.clusters>`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CollectorCluster {
      get { return collectorCluster_; }
      set {
        collectorCluster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "collector_endpoint" field.</summary>
    public const int CollectorEndpointFieldNumber = 2;
    private string collectorEndpoint_ = "";
    /// <summary>
    /// The API endpoint of the Zipkin service where the spans will be sent. When
    /// using a standard Zipkin installation, the API endpoint is typically
    /// /api/v1/spans, which is the default value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CollectorEndpoint {
      get { return collectorEndpoint_; }
      set {
        collectorEndpoint_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ZipkinConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ZipkinConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (CollectorCluster != other.CollectorCluster) return false;
      if (CollectorEndpoint != other.CollectorEndpoint) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (CollectorCluster.Length != 0) hash ^= CollectorCluster.GetHashCode();
      if (CollectorEndpoint.Length != 0) hash ^= CollectorEndpoint.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (CollectorCluster.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(CollectorCluster);
      }
      if (CollectorEndpoint.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(CollectorEndpoint);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (CollectorCluster.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CollectorCluster);
      }
      if (CollectorEndpoint.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CollectorEndpoint);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ZipkinConfig other) {
      if (other == null) {
        return;
      }
      if (other.CollectorCluster.Length != 0) {
        CollectorCluster = other.CollectorCluster;
      }
      if (other.CollectorEndpoint.Length != 0) {
        CollectorEndpoint = other.CollectorEndpoint;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            CollectorCluster = input.ReadString();
            break;
          }
          case 18: {
            CollectorEndpoint = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// DynamicOtConfig is used to dynamically load a tracer from a shared library
  /// that implements the `OpenTracing dynamic loading API
  /// &lt;https://github.com/opentracing/opentracing-cpp>`_.
  /// </summary>
  public sealed partial class DynamicOtConfig : pb::IMessage<DynamicOtConfig> {
    private static readonly pb::MessageParser<DynamicOtConfig> _parser = new pb::MessageParser<DynamicOtConfig>(() => new DynamicOtConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DynamicOtConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Trace.V2.TraceReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DynamicOtConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DynamicOtConfig(DynamicOtConfig other) : this() {
      library_ = other.library_;
      Config = other.config_ != null ? other.Config.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DynamicOtConfig Clone() {
      return new DynamicOtConfig(this);
    }

    /// <summary>Field number for the "library" field.</summary>
    public const int LibraryFieldNumber = 1;
    private string library_ = "";
    /// <summary>
    /// Dynamic library implementing the `OpenTracing API
    /// &lt;https://github.com/opentracing/opentracing-cpp>`_.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Library {
      get { return library_; }
      set {
        library_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "config" field.</summary>
    public const int ConfigFieldNumber = 2;
    private global::Google.Protobuf.WellKnownTypes.Struct config_;
    /// <summary>
    /// The configuration to use when creating a tracer from the given dynamic
    /// library.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Struct Config {
      get { return config_; }
      set {
        config_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DynamicOtConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DynamicOtConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Library != other.Library) return false;
      if (!object.Equals(Config, other.Config)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Library.Length != 0) hash ^= Library.GetHashCode();
      if (config_ != null) hash ^= Config.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Library.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Library);
      }
      if (config_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Config);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Library.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Library);
      }
      if (config_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Config);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DynamicOtConfig other) {
      if (other == null) {
        return;
      }
      if (other.Library.Length != 0) {
        Library = other.Library;
      }
      if (other.config_ != null) {
        if (config_ == null) {
          config_ = new global::Google.Protobuf.WellKnownTypes.Struct();
        }
        Config.MergeFrom(other.Config);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Library = input.ReadString();
            break;
          }
          case 18: {
            if (config_ == null) {
              config_ = new global::Google.Protobuf.WellKnownTypes.Struct();
            }
            input.ReadMessage(config_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Configuration structure.
  /// </summary>
  public sealed partial class TraceServiceConfig : pb::IMessage<TraceServiceConfig> {
    private static readonly pb::MessageParser<TraceServiceConfig> _parser = new pb::MessageParser<TraceServiceConfig>(() => new TraceServiceConfig());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TraceServiceConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Envoy.Config.Trace.V2.TraceReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TraceServiceConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TraceServiceConfig(TraceServiceConfig other) : this() {
      GrpcService = other.grpcService_ != null ? other.GrpcService.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TraceServiceConfig Clone() {
      return new TraceServiceConfig(this);
    }

    /// <summary>Field number for the "grpc_service" field.</summary>
    public const int GrpcServiceFieldNumber = 1;
    private global::Envoy.Api.V2.Core.GrpcService grpcService_;
    /// <summary>
    /// The upstream gRPC cluster that hosts the metrics service.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Envoy.Api.V2.Core.GrpcService GrpcService {
      get { return grpcService_; }
      set {
        grpcService_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TraceServiceConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TraceServiceConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(GrpcService, other.GrpcService)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (grpcService_ != null) hash ^= GrpcService.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (grpcService_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(GrpcService);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (grpcService_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(GrpcService);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TraceServiceConfig other) {
      if (other == null) {
        return;
      }
      if (other.grpcService_ != null) {
        if (grpcService_ == null) {
          grpcService_ = new global::Envoy.Api.V2.Core.GrpcService();
        }
        GrpcService.MergeFrom(other.GrpcService);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            if (grpcService_ == null) {
              grpcService_ = new global::Envoy.Api.V2.Core.GrpcService();
            }
            input.ReadMessage(grpcService_);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
